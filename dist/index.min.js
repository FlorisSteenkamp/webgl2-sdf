var __webpack_modules__={"./src/bezier/bezier-curves-to-line-segs.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierCurvesToLineSegs: () => (/* binding */ bezierCurvesToLineSegs)\n/* harmony export */ });\n/* harmony import */ var _is_really_point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-really-point.js */ "./src/bezier/is-really-point.ts");\n/* harmony import */ var _split_into_line_segments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-into-line-segments.js */ "./src/bezier/split-into-line-segments.ts");\n\n\n/**\n * Returns an array of line segments that is an approximation of the given\n * bezier curves up to `PIXEL_ACCURACY` accuracy.\n *\n * @param bezierLoops\n * @param resolution each bezier curve is split until its hausdorff distance\n * from the line connecting it\'s endpoints are less than this value\n */\nfunction bezierCurvesToLineSegs(bezierLoops, resolution) {\n    let lineSegs = [];\n    for (let i = 0; i < bezierLoops.length; i++) {\n        const pss = bezierLoops[i];\n        for (let j = 0; j < pss.length; j++) {\n            const ps = pss[j];\n            if ((0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_0__.isReallyPoint)(ps)) {\n                continue;\n            }\n            if (ps.length === 2) {\n                lineSegs.push(ps);\n                continue;\n            }\n            const lineSegs_ = (0,_split_into_line_segments_js__WEBPACK_IMPORTED_MODULE_1__.splitIntoLineSegments)(ps, resolution);\n            lineSegs.push(...lineSegs_.filter(ps => !(0,_is_really_point_js__WEBPACK_IMPORTED_MODULE_0__.isReallyPoint)(ps)));\n        }\n    }\n    return lineSegs;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/bezier-curves-to-line-segs.ts?\n}')},"./src/bezier/eval-de-casteljau.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalDeCasteljau: () => (/* binding */ evalDeCasteljau)\n/* harmony export */ });\n/**\n * Returns the resulting point of evaluating the given bezier curve at the\n * given parameter `t`.\n *\n * * uses [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)\n * in double precision floating point arithmetic\n *\n * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are\n * double precision floating point numbers.\n *\n * @param ps an order 1,2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n * @param t the parameter value where the bezier should be evaluated\n *\n * @doc mdx\n **/\nfunction evalDeCasteljau(ps, t) {\n    if (t === 0) {\n        return ps[0];\n    }\n    else if (t === 1) {\n        return ps[ps.length - 1];\n    }\n    if (ps.length === 4) {\n        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        const a01 = x0 + (x1 - x0) * t;\n        const a11 = x1 + (x2 - x1) * t;\n        const a21 = x2 + (x3 - x2) * t;\n        const a02 = a01 + (a11 - a01) * t;\n        const a12 = a11 + (a21 - a11) * t;\n        const x = a02 + (a12 - a02) * t;\n        const b01 = y0 + (y1 - y0) * t;\n        const b11 = y1 + (y2 - y1) * t;\n        const b21 = y2 + (y3 - y2) * t;\n        const b02 = b01 + (b11 - b01) * t;\n        const b12 = b11 + (b21 - b11) * t;\n        const y = b02 + (b12 - b02) * t;\n        return [x, y];\n    }\n    if (ps.length === 3) {\n        const [[x0, y0], [x1, y1], [x2, y2]] = ps;\n        const a01 = x0 + (x1 - x0) * t;\n        const a11 = x1 + (x2 - x1) * t;\n        const x = a01 + (a11 - a01) * t;\n        const b01 = y0 + (y1 - y0) * t;\n        const b11 = y1 + (y2 - y1) * t;\n        const y = b01 + (b11 - b01) * t;\n        return [x, y];\n    }\n    if (ps.length === 2) {\n        const [[x0, y0], [x1, y1]] = ps;\n        const x = x0 + (x1 - x0) * t;\n        const y = y0 + (y1 - y0) * t;\n        return [x, y];\n    }\n    if (ps.length === 1) {\n        return ps[0];\n    }\n    throw new Error('The given bezier curve must be of order <= 3.');\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/eval-de-casteljau.ts?\n}")},"./src/bezier/from-to/from-to-2.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo2: () => (/* binding */ fromTo2)\n/* harmony export */ });\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo2(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return ps;\n        }\n        return splitLeft2(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight2(ps, tS);\n    }\n    return splitAtBoth2(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given t parameter and ends\n * at `t === 1`.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight2(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    // --------------------------------------------------------\n    const tt = t * t;\n    const xA = x0 - x1;\n    const xB = x2 - x1;\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    return [\n        [tt * (xA + xB) - (2 * t * xA - x0), // xx0, split point x\n            tt * (yA + yB) - (2 * t * yA - y0)], // yy0, split point y\n        [t * xB + x1, // xx1\n            t * yB + y1], // yy1\n        p2\n    ];\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given `t`\n * parameter.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft2(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    // --------------------------------------------------------\n    const tt = t * t;\n    const xA = x0 - x1;\n    const yA = y0 - y1;\n    return [\n        p0,\n        [-t * xA + x0, // xx1\n            -t * yA + y0], // yy1\n        [tt * (xA + (x2 - x1)) - (2 * t * xA - x0), // xx2 - split point x\n            tt * (yA + (y2 - y1)) - (2 * t * yA - y0)] // yy2 - split point y\n    ];\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a quadratic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth2(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    // --------------------------------------------------------\n    const ttS = tS * tS;\n    const ttE = tE * tE;\n    const tStE = tS * tE;\n    const xA = x0 - x1;\n    const xB = x2 - x1;\n    const xC = xA + xB;\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const yC = yA + yB;\n    const xx0 = ttS * xC - (2 * tS * xA - x0);\n    const xx1 = tStE * xC - (xA * (tE + tS) - x0);\n    const xx2 = ttE * xC - (2 * tE * xA - x0);\n    const yy0 = ttS * yC - (2 * tS * yA - y0);\n    const yy1 = tStE * yC - (yA * (tE + tS) - y0);\n    const yy2 = ttE * yC - (2 * tE * yA - y0);\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2]];\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/from-to/from-to-2.ts?\n}")},"./src/bezier/from-to/from-to-3.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo3: () => (/* binding */ fromTo3)\n/* harmony export */ });\n/**\n * Returns a bezier curve that starts and ends at the given t parameters.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction fromTo3(ps, tS, tE) {\n    if (tS === 0) {\n        if (tE === 1) {\n            return ps;\n        }\n        return splitLeft3(ps, tE);\n    }\n    if (tE === 1) {\n        return splitRight3(ps, tS);\n    }\n    return splitAtBoth3(ps, tS, tE);\n}\n/**\n * Returns a bezier curve that starts at the given t parameter and ends\n * at `t === 1`.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t the `t` parameter where the resultant bezier should start\n *\n * @internal\n */\nfunction splitRight3(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x00 = p0[0];\n    const y00 = p0[1];\n    const x10 = p1[0];\n    const y10 = p1[1];\n    const x20 = p2[0];\n    const y20 = p2[1];\n    const x30 = p3[0];\n    const y30 = p3[1];\n    // --------------------------------------------------------\n    const x01 = x00 - t * (x00 - x10);\n    const x11 = x10 - t * (x10 - x20);\n    const x21 = x20 - t * (x20 - x30);\n    const x02 = x01 - t * (x01 - x11);\n    const x12 = x11 - t * (x11 - x21);\n    const x03 = x02 - t * (x02 - x12);\n    const y01 = y00 - t * (y00 - y10);\n    const y11 = y10 - t * (y10 - y20);\n    const y21 = y20 - t * (y20 - y30);\n    const y02 = y01 - t * (y01 - y11);\n    const y12 = y11 - t * (y11 - y21);\n    const y03 = y02 - t * (y02 - y12);\n    return [[x03, y03], [x12, y12], [x21, y21], p3];\n}\n/**\n * Returns a bezier curve that starts at `t === 0` and ends at the given t\n * parameter.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param t the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitLeft3(ps, t) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x00 = p0[0];\n    const y00 = p0[1];\n    const x10 = p1[0];\n    const y10 = p1[1];\n    const x20 = p2[0];\n    const y20 = p2[1];\n    const x30 = p3[0];\n    const y30 = p3[1];\n    // --------------------------------------------------------\n    const x01 = x00 - t * (x00 - x10);\n    const x11 = x10 - t * (x10 - x20);\n    const x21 = x20 - t * (x20 - x30);\n    const x02 = x01 - t * (x01 - x11);\n    const x12 = x11 - t * (x11 - x21);\n    const x03 = x02 - t * (x02 - x12);\n    const y01 = y00 - t * (y00 - y10);\n    const y11 = y10 - t * (y10 - y20);\n    const y21 = y20 - t * (y20 - y30);\n    const y02 = y01 - t * (y01 - y11);\n    const y12 = y11 - t * (y11 - y21);\n    const y03 = y02 - t * (y02 - y12);\n    return [p0, [x01, y01], [x02, y02], [x03, y03]];\n}\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps a cubic bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n *\n * @internal\n */\nfunction splitAtBoth3(ps, tS, tE) {\n    // --------------------------------------------------------\n    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; \n    const p0 = ps[0];\n    const p1 = ps[1];\n    const p2 = ps[2];\n    const p3 = ps[3];\n    const x0 = p0[0];\n    const y0 = p0[1];\n    const x1 = p1[0];\n    const y1 = p1[1];\n    const x2 = p2[0];\n    const y2 = p2[1];\n    const x3 = p3[0];\n    const y3 = p3[1];\n    // --------------------------------------------------------\n    const ttS = tS * tS;\n    const tttS = tS * ttS;\n    const ttE = tE * tE;\n    const tttE = tE * ttE;\n    const tStE = tS * tE;\n    const xA = x0 - x1;\n    const xB = x2 - x1;\n    const xC = x3 - x0;\n    const xD = xA + xB;\n    const tSxA = tS * xA;\n    const tExA = tE * xA;\n    const xC3xB = xC - 3 * xB;\n    const yA = y0 - y1;\n    const yB = y2 - y1;\n    const yC = y3 - y0;\n    const yD = yA + yB;\n    const tSyA = tS * yA;\n    const tEyA = tE * yA;\n    const yC3yB = yC - 3 * yB;\n    const xx0 = tttS * xC3xB + (3 * tS * (tS * xD - xA) + x0);\n    const xx1 = tStE * (tS * xC3xB + 2 * xD) + ((ttS * xD + x0) - (tExA + 2 * tSxA));\n    const xx2 = tStE * (tE * xC3xB + 2 * xD) + ((ttE * xD + x0) - (2 * tExA + tSxA));\n    const xx3 = tttE * xC3xB + (3 * tE * (tE * xD - xA) + x0);\n    const yy0 = tttS * yC3yB + (3 * tS * (tS * yD - yA) + y0);\n    const yy1 = tStE * (tS * yC3yB + 2 * yD) + ((ttS * yD + y0) - (tEyA + 2 * tSyA));\n    const yy2 = tStE * (tE * yC3yB + 2 * yD) + ((ttE * yD + y0) - (2 * tEyA + tSyA));\n    const yy3 = tttE * yC3yB + (3 * tE * (tE * yD - yA) + y0);\n    return [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]];\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/from-to/from-to-3.ts?\n}")},"./src/bezier/from-to/from-to.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTo: () => (/* binding */ fromTo)\n/* harmony export */ });\n/* harmony import */ var _from_to_2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./from-to-2.js */ "./src/bezier/from-to/from-to-2.ts");\n/* harmony import */ var _from_to_3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to-3.js */ "./src/bezier/from-to/from-to-3.ts");\n\n\n/**\n * Returns a bezier curve that starts and ends at the given `t` parameters.\n *\n * @param ps an order 2 or 3 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1], [2,0]]`\n * @param tS the `t` parameter where the resultant bezier should start\n * @param tE the `t` parameter where the resultant bezier should end\n */\nfunction fromTo(ps, tS, tE) {\n    if (ps.length === 4) {\n        return (0,_from_to_3_js__WEBPACK_IMPORTED_MODULE_1__.fromTo3)(ps, tS, tE);\n    }\n    if (ps.length === 3) {\n        return (0,_from_to_2_js__WEBPACK_IMPORTED_MODULE_0__.fromTo2)(ps, tS, tE);\n    }\n    throw new Error(\'The given bezier curve must be of order 2 or 3.\');\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/from-to/from-to.ts?\n}')},"./src/bezier/is-cubic-obtuse.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isCubicObtuse: () => (/* binding */ isCubicObtuse)\n/* harmony export */ });\n/* harmony import */ var _vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vector/from-to-vec.js */ "./src/vector/from-to-vec.ts");\n/* harmony import */ var _vector_dot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vector/dot.js */ "./src/vector/dot.ts");\n\n\n/**\n * Returns `true` if the given cubic bezier is obtuse, `false` otherwise (i.e.\n * `false` if acute).\n *\n * Obtuse here is defined as follows: let the cubic form triangles through its\n * control points P0, P1, P3 where P0 and P3 are the endpoints. If both interior\n * angles ∠P0 and ∠P2 are <= 90 degrees then the cubic is considered acute,\n * otherwise it is considered obtuse. The same should be true for P0, P2, P3.\n */\nfunction isCubicObtuse(ps) {\n    const v0 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[0], ps[1]);\n    const v1 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[1], ps[3]);\n    const v2 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[3], ps[0]);\n    const v3 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[0], ps[2]);\n    const v4 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[2], ps[3]);\n    return ((0,_vector_dot_js__WEBPACK_IMPORTED_MODULE_1__.dot)(v2, v0) > 0 ||\n        (0,_vector_dot_js__WEBPACK_IMPORTED_MODULE_1__.dot)(v1, v2) > 0 ||\n        (0,_vector_dot_js__WEBPACK_IMPORTED_MODULE_1__.dot)(v2, v3) > 0 ||\n        (0,_vector_dot_js__WEBPACK_IMPORTED_MODULE_1__.dot)(v4, v2) > 0);\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/is-cubic-obtuse.ts?\n}')},"./src/bezier/is-quad-obtuse.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isQuadObtuse: () => (/* binding */ isQuadObtuse)\n/* harmony export */ });\n/* harmony import */ var _vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vector/from-to-vec.js */ "./src/vector/from-to-vec.ts");\n/* harmony import */ var _vector_dot_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vector/dot.js */ "./src/vector/dot.ts");\n\n\n/**\n * Returns `true` if the given quadratic bezier is obtuse, `false` otherwise (i.e.\n * `false` if acute).\n *\n * Obtuse here is defined as follows: let the quad form a triangle through its\n * control points P0, P1, P2 where P0 and P2 are the endpoints. If both interior\n * angles ∠P0 and ∠P2 are <= 90 degrees then the quad is considered acute,\n * otherwise it is considered obtuse.\n */\nfunction isQuadObtuse(ps) {\n    const v0 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[0], ps[1]);\n    const v1 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[1], ps[2]);\n    const v2 = (0,_vector_from_to_vec_js__WEBPACK_IMPORTED_MODULE_0__.fromToVec)(ps[2], ps[0]);\n    return ((0,_vector_dot_js__WEBPACK_IMPORTED_MODULE_1__.dot)(v2, v0) > 0 ||\n        (0,_vector_dot_js__WEBPACK_IMPORTED_MODULE_1__.dot)(v1, v2) > 0);\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/is-quad-obtuse.ts?\n}')},"./src/bezier/is-really-point.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isReallyPoint: () => (/* binding */ isReallyPoint)\n/* harmony export */ });\n/**\n * Returns `true` if the given bezier curve has all control points coincident,\n * `false` otherwise.\n *\n * @param ps an order 0,1,2 or 3 bezier curve given as an array of its control\n * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`\n */\nfunction isReallyPoint(ps) {\n    const x = ps[0][0];\n    const y = ps[0][1];\n    for (let i = 1; i < ps.length; i++) {\n        if (x !== ps[i][0] || y !== ps[i][1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/is-really-point.ts?\n}")},"./src/bezier/split-by-deviation-from-straight-line-cubic.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitByDeviationFromStraighLine_Cubic_Crude: () => (/* binding */ splitByDeviationFromStraighLine_Cubic_Crude)\n/* harmony export */ });\n/* harmony import */ var _utils_get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/get-distance-to-line-function.js */ "./src/utils/get-distance-to-line-function.ts");\n/* harmony import */ var _from_to_from_to_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./from-to/from-to.js */ "./src/bezier/from-to/from-to.ts");\n/* harmony import */ var _is_cubic_obtuse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-cubic-obtuse.js */ "./src/bezier/is-cubic-obtuse.ts");\n\n\n\nconst { abs, max } = Math;\n/**\n * Split the given cubic bezier curve into pieces (given as an array of\n * parameter `t` values) such that each piece is guaranteed to deviate less\n * than `maxD` from a straigh line.\n *\n * * a crude method is employed (for efficiency) by noting that the hausdorff\n * distance between a cubic and the line segment connecting its endpoints is at\n * most 3/4 the distance of the max distance between any control point and the\n * line segment if the control points are on the same side of the line segment\n * and at most 4/9 if they are on opposite sides AND (in both cases) the cubic\n * is not obtuse, i.e. the inner control points are not outside the strip formed\n * by the two lines passing through the endpoint control points normal to the\n * line segment connecting the endpoint control points.\n *\n * @param ps an order 2 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param maxD\n */\nfunction splitByDeviationFromStraighLine_Cubic_Crude(ps, maxD) {\n    const tsS = [0];\n    const tsE = [1];\n    while (true) {\n        const tS = tsS[tsS.length - 1];\n        const tE = tsE[tsE.length - 1];\n        const ps_ = (0,_from_to_from_to_js__WEBPACK_IMPORTED_MODULE_1__.fromTo)(ps, tS, tE);\n        if ((!(0,_is_cubic_obtuse_js__WEBPACK_IMPORTED_MODULE_2__.isCubicObtuse)(ps_) && getMaxD(ps_) <= maxD)) {\n            tsS.push(tsE.pop());\n            if (tE === 1) {\n                return tsS;\n            }\n            continue;\n        }\n        const t = (tS + tE) / 2;\n        tsE.push(t);\n    }\n}\n// function splitByDeviationFromStraighLine_Cubic_Precise(\n//         ps: number[][], \n//         maxD: number): number[] {\n//     const tsS = [0];\n//     const tsE = [1];\n//     while (true) {\n//         const tS = tsS[tsS.length - 1];\n//         const tE = tsE[tsE.length - 1];\n//         const ps_ = fromTo(ps, tS, tE);\n//         if ((!isCubicObtuse(ps_) && getMaxDPrecise(ps_) <= maxD)) {\n//             tsS.push(tsE.pop()!);\n//             if (tE === 1) {\n//                 return tsS;\n//             }\n//             continue;\n//         }\n//         const t = (tS + tE)/2;\n//         tsE.push(t);\n//     }\n// }\nfunction getMaxD(ps) {\n    const dF = (0,_utils_get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_0__.getDistanceToLineFunction)(ps[0], ps[3]);\n    const d1 = dF(ps[1]);\n    const d2 = dF(ps[2]);\n    // The hausdorff distance between a cubic and the line segment connecting its\n    // endpoints is at most 3/4 the distance of the max distance between any control\n    // point and the line segment if the control points are on the same side of the line\n    // segment and at most 4/9 if they are on opposite sides AND (in both cases) the cubic\n    // is not obtuse, i.e. the inner control points are not outside the strip formed\n    // by the two lines passing through the endpoint control points normal to the\n    // line segment connecting the endpoint control points.\n    const C = d1 * d2 <= 0 ? 4 / 9 : 3 / 4;\n    return C * max(abs(d1), abs(d2));\n}\n\n// Quokka tests\n// splitByDeviationFromStraighLine_Cubic_Crude([\n//     [43, 0],\n//     [23, 0],\n//     [33, 0],\n//     [53, 0]\n// ], 0.5);//?\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/split-by-deviation-from-straight-line-cubic.ts?\n}')},"./src/bezier/split-by-deviation-from-straight-line-quad.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitByDeviationFromStraighLine_Quad: () => (/* binding */ splitByDeviationFromStraighLine_Quad)\n/* harmony export */ });\n/* harmony import */ var _utils_get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/get-distance-to-line-function.js */ "./src/utils/get-distance-to-line-function.ts");\n/* harmony import */ var _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eval-de-casteljau.js */ "./src/bezier/eval-de-casteljau.ts");\n/* harmony import */ var _from_to_from_to_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./from-to/from-to.js */ "./src/bezier/from-to/from-to.ts");\n/* harmony import */ var _is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-quad-obtuse.js */ "./src/bezier/is-quad-obtuse.ts");\n\n\n\n\nconst { abs } = Math;\n/**\n * Split the given quadratic bezier curve into pieces (given as an array of\n * parameter `t` values) such that each piece is guaranteed to deviate less\n * than `maxD` from a straigh line.\n *\n * @param ps an order 2 bezier curve given as an ordered array of its\n * control point coordinates, e.g. `[[0,0], [1,1], [2,1]]`\n * @param maxD\n */\nfunction splitByDeviationFromStraighLine_Quad(ps, maxD) {\n    const tsS = [0];\n    const tsE = [1];\n    while (true) {\n        const tS = tsS[tsS.length - 1];\n        const tE = tsE[tsE.length - 1];\n        const ps_ = (0,_from_to_from_to_js__WEBPACK_IMPORTED_MODULE_2__.fromTo)(ps, tS, tE);\n        if ((!(0,_is_quad_obtuse_js__WEBPACK_IMPORTED_MODULE_3__.isQuadObtuse)(ps_) && getMaxD(ps_) <= maxD)) {\n            tsS.push(tsE.pop());\n            if (tE === 1) {\n                return tsS;\n            }\n            continue;\n        }\n        const t = (tS + tE) / 2;\n        tsE.push(t);\n    }\n}\nfunction getMaxD(ps) {\n    if (ps[0][0] === ps[1][0] && ps[0][1] === ps[1][1]) {\n        return 0;\n    }\n    const p = (0,_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_1__.evalDeCasteljau)(ps, 0.5); // peak is reached at t = 0.5\n    const dF = (0,_utils_get_distance_to_line_function_js__WEBPACK_IMPORTED_MODULE_0__.getDistanceToLineFunction)(ps[0], ps[2]);\n    const d = abs(dF(p));\n    return d;\n}\n\n// Quokka tests\n// splitByDeviationFromStraighLine_Quad([[0,0],[0,4],[-3,4],[20,0]], 0.25);//?\n// splitByDeviationFromStraighLine_Quad([\n//     [128, 423],\n//     [128, 423],\n//     [128, 423]\n// ]);//?\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/split-by-deviation-from-straight-line-quad.ts?\n}')},"./src/bezier/split-into-line-segments.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   splitIntoLineSegments: () => (/* binding */ splitIntoLineSegments)\n/* harmony export */ });\n/* harmony import */ var _eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eval-de-casteljau.js */ "./src/bezier/eval-de-casteljau.ts");\n/* harmony import */ var _split_by_deviation_from_straight_line_cubic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-by-deviation-from-straight-line-cubic.js */ "./src/bezier/split-by-deviation-from-straight-line-cubic.ts");\n/* harmony import */ var _split_by_deviation_from_straight_line_quad_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./split-by-deviation-from-straight-line-quad.js */ "./src/bezier/split-by-deviation-from-straight-line-quad.ts");\n\n\n// import { splitByDeviationFromStraighLine_Cubic_Precise } from \'./split-by-deviation-from-straight-line-cubic\';\n\n/**\n * Returns the result of splitting the given bezier curve into straight line\n * segments up to `maxDeviation`\n *\n *\n * @param ps\n * @param maxDeviation maximum deviation from straight line\n */\nfunction splitIntoLineSegments(ps, maxDeviation) {\n    const ts = ps.length === 3\n        ? (0,_split_by_deviation_from_straight_line_quad_js__WEBPACK_IMPORTED_MODULE_2__.splitByDeviationFromStraighLine_Quad)(ps, maxDeviation)\n        // : splitByDeviationFromStraighLine_Cubic_Precise(ps, maxDeviation)\n        : (0,_split_by_deviation_from_straight_line_cubic_js__WEBPACK_IMPORTED_MODULE_1__.splitByDeviationFromStraighLine_Cubic_Crude)(ps, maxDeviation);\n    const segs = [];\n    for (let i = 0; i < ts.length - 1; i++) {\n        const p0 = (0,_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, ts[i]);\n        const p1 = (0,_eval_de_casteljau_js__WEBPACK_IMPORTED_MODULE_0__.evalDeCasteljau)(ps, ts[i + 1]);\n        segs.push([p0, p1]);\n    }\n    return segs;\n}\n\n// Quokka tests\n// splitByDeviationFromStraighLine([[0,0],[0,4],[-3,4],[20,0]], 0.25);//?\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/bezier/split-into-line-segments.ts?\n}')},"./src/generate-sdf.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateIntoFramebuffer: () => (/* binding */ generateIntoFramebuffer)\n/* harmony export */ });\n/* harmony import */ var _shaders_main_vertex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/main.vertex.js */ "./src/shaders/main.vertex.ts");\n/* harmony import */ var _shaders_main_fragment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/main.fragment.js */ "./src/shaders/main.fragment.ts");\n/* harmony import */ var _webgl_utils_use_program_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-utils/use-program.js */ "./src/webgl-utils/use-program.ts");\n/* harmony import */ var _main_program_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main-program.js */ "./src/main-program.ts");\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./row-count.js */ "./src/row-count.ts");\n/* harmony import */ var _svg_get_paths_from_str_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./svg/get-paths-from-str.js */ "./src/svg/get-paths-from-str.ts");\n/* harmony import */ var _max_aspect_ratio_before_stretch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./max-aspect-ratio-before-stretch.js */ "./src/max-aspect-ratio-before-stretch.ts");\n// import { getWebGLContext } from \'./webgl-utils/get-gl-context.js\';\n\n\n\n\n\n\n\n// import { debugShaders } from \'./debug-shaders.js\';\nconst { ceil, min, max } = Math;\n/**\n * TODO\n * @param gl\n * @param psss\n * @param width\n * @param height\n * @param viewbox\n * @param maxDistance\n * @param sdfExponent\n * @param inclInside\n * @param inclOutside\n * @param x\n * @param y\n * @param channel\n * @param resolution\n */\nfunction generateIntoFramebuffer(glContext, psss, width, height, viewbox, maxDistance, sdfExponent = 1, inclInside = true, inclOutside = true, x = 0, y = 0, channel = 0, resolution = 0.5) {\n    // debugShaders(gl);  // comment for production\n    const psss_ = typeof psss === \'string\'\n        ? (0,_svg_get_paths_from_str_js__WEBPACK_IMPORTED_MODULE_5__.getPathsFromStr)(psss)\n        : psss;\n    // const glContext = getWebGLContext(gl);\n    const { onContextLoss } = glContext;\n    let stretch = 1;\n    const aspectRatio = width / height;\n    if (aspectRatio > _max_aspect_ratio_before_stretch_js__WEBPACK_IMPORTED_MODULE_6__.MAX_ASPECT_RATIO_BEFORE_STRETCH) {\n        const r = width / _max_aspect_ratio_before_stretch_js__WEBPACK_IMPORTED_MODULE_6__.MAX_ASPECT_RATIO_BEFORE_STRETCH;\n        stretch = r / height;\n        height = r;\n    }\n    const cellSize = height / _row_count_js__WEBPACK_IMPORTED_MODULE_4__.ROW_COUNT;\n    const maxDim = max(width, height);\n    const colCount = ceil(width / cellSize);\n    const padCount = 2 * ceil(min(maxDistance, maxDim) / cellSize / 2);\n    const programMain = (0,_webgl_utils_use_program_js__WEBPACK_IMPORTED_MODULE_2__.initProgram)(glContext, `main${colCount}-${padCount}`, _shaders_main_vertex_js__WEBPACK_IMPORTED_MODULE_0__.main_Vertex, (0,_shaders_main_fragment_js__WEBPACK_IMPORTED_MODULE_1__.getMainFragment)(colCount, padCount));\n    const { gl } = glContext;\n    gl.useProgram(programMain.program);\n    (0,_main_program_js__WEBPACK_IMPORTED_MODULE_3__.mainProgram)(glContext, programMain, resolution, psss_, viewbox, maxDistance, sdfExponent, width, height, colCount, cellSize, inclInside, inclOutside, padCount, stretch);\n    // Handle context loss occurring during any of the above calls\n    if (gl.isContextLost()) {\n        onContextLoss();\n        throw new Error(\'Webgl2 context lost.\');\n    }\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/generate-sdf.ts?\n}')},"./src/index.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   freeGlContext: () => (/* reexport safe */ _webgl_utils_free_gl_context_js__WEBPACK_IMPORTED_MODULE_1__.freeGlContext),\n/* harmony export */   generateIntoFramebuffer: () => (/* reexport safe */ _generate_sdf_js__WEBPACK_IMPORTED_MODULE_0__.generateIntoFramebuffer),\n/* harmony export */   getWebGlContext: () => (/* reexport safe */ _webgl_utils_get_gl_context_js__WEBPACK_IMPORTED_MODULE_2__.getWebGlContext)\n/* harmony export */ });\n/* harmony import */ var _generate_sdf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generate-sdf.js */ "./src/generate-sdf.ts");\n/* harmony import */ var _webgl_utils_free_gl_context_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-utils/free-gl-context.js */ "./src/webgl-utils/free-gl-context.ts");\n/* harmony import */ var _webgl_utils_get_gl_context_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-utils/get-gl-context.js */ "./src/webgl-utils/get-gl-context.ts");\n\n\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/index.ts?\n}')},"./src/main-program.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mainProgram: () => (/* binding */ mainProgram)\n/* harmony export */ });\n/* harmony import */ var _webgl_utils_use_texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-utils/use-texture.js */ \"./src/webgl-utils/use-texture.ts\");\n/* harmony import */ var _webgl_utils_set_attribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-utils/set-attribute.js */ \"./src/webgl-utils/set-attribute.ts\");\n/* harmony import */ var _webgl_utils_set_uniform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-utils/set-uniform.js */ \"./src/webgl-utils/set-uniform.ts\");\n/* harmony import */ var _webgl_utils_set_uniform_block_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl-utils/set-uniform-block.js */ \"./src/webgl-utils/set-uniform-block.ts\");\n/* harmony import */ var _prepare_buffers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prepare-buffers.js */ \"./src/prepare-buffers.ts\");\n/* harmony import */ var _tex_width_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tex-width.js */ \"./src/tex-width.ts\");\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./row-count.js */ \"./src/row-count.ts\");\n\n\n\n\n\n\n\nconst SEG_TEX_INDEX = 0;\nconst CELL_TEX_INDEX = 1;\nconst CROSS_TEX_INDEX = 2;\nfunction mainProgram(glContext, programMain, resolution, psss, viewbox, maxDistance, sdfExponent = 1, width, height, colCount, cellSize, inclInside, inclOutside, padCount, stretch) {\n    const { gl } = glContext;\n    const vertices = [];\n    const x0 = 0;\n    const y0 = 0;\n    const x1 = 1 / _row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT;\n    const y1 = 1 / _row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT;\n    vertices.push(x0, y0, x1, y0, x0, y1); // First triangle: (x0,y0), (x1,y0), (x0,y1)\n    vertices.push(x1, y0, x1, y1, x0, y1); // Second triangle: (x1,y0), (x1,y1), (x0,y1)\n    const uvArr = new Float32Array(vertices);\n    const setUniform_ = (0,_webgl_utils_set_uniform_js__WEBPACK_IMPORTED_MODULE_2__.setUniform)(programMain);\n    const setAttribute_ = (0,_webgl_utils_set_attribute_js__WEBPACK_IMPORTED_MODULE_1__.setAttribute)(programMain);\n    const { lineSegPtCoords_Arr, segIdxs_PerCell_Range_Arr, closeCellIdxs_PerCell_Arr, closeCellIdxs_PerCell_Range_Arr, crossCellIdxs_PerCell_Arr, crossCellIdxs_perCell_Range_Arr, segIdxs_PerStrip_Range_Arr } = (0,_prepare_buffers_js__WEBPACK_IMPORTED_MODULE_4__.prepareBuffers)(psss, width, height, colCount, cellSize, maxDistance, padCount, resolution, viewbox, stretch);\n    // Init/update attributes\n    setAttribute_('aUV', 2, // size, i.e 2d - draw 2 values each time\n    gl.FLOAT, gl.STATIC_DRAW, uvArr);\n    setAttribute_('aCrossIdxRangePerCell', 2, // count\n    gl.INT, gl.STATIC_DRAW, crossCellIdxs_perCell_Range_Arr, 1 // instance division (once per instance)\n    );\n    setAttribute_('aCloseCellIdxRangePerCell', 2, // count\n    gl.INT, gl.STATIC_DRAW, closeCellIdxs_PerCell_Range_Arr, 1 // instance division (once per instance)\n    );\n    // Init/update uniforms\n    setUniform_('2f', 'uWidthHeight', width, height);\n    setUniform_('1f', 'uMaxDistance', maxDistance);\n    setUniform_('1f', 'uExponent', sdfExponent); // TODO\n    setUniform_('1i', 'uIncl', (inclInside ? 1 : 0) + (inclOutside ? 2 : 0));\n    (0,_webgl_utils_set_uniform_block_js__WEBPACK_IMPORTED_MODULE_3__.setUniformBlock)(programMain)('SegIdxRangePerCellBlock', 0, segIdxs_PerCell_Range_Arr);\n    (0,_webgl_utils_set_uniform_block_js__WEBPACK_IMPORTED_MODULE_3__.setUniformBlock)(programMain)('SegIdxRangePerStripBlock', 1, segIdxs_PerStrip_Range_Arr);\n    ///////////////////////////////////////\n    // Create buffer for line segment data\n    (0,_webgl_utils_use_texture_js__WEBPACK_IMPORTED_MODULE_0__.useTexture)(glContext, SEG_TEX_INDEX, 'segs');\n    gl.texImage2D(// really 1d\n    gl.TEXTURE_2D, 0, // level - irrelevant\n    gl.RGBA32F, // internalFormat - we're using 4 floats for the 2 line segment endpoints\n    lineSegPtCoords_Arr.length / 4, // width === number of lines\n    1, // height - linear data texture so we only need height of 1\n    0, // border - whatever\n    gl.RGBA, // format\n    gl.FLOAT, // it holds floats\n    lineSegPtCoords_Arr // texture data\n    );\n    const segTexLoc = gl.getUniformLocation(programMain.program, \"uSegs\");\n    gl.uniform1i(segTexLoc, SEG_TEX_INDEX);\n    ///////////////////////////////////////////////\n    ///////////////////////////////////////////////\n    // Create buffer for close cell indexes per cell\n    (0,_webgl_utils_use_texture_js__WEBPACK_IMPORTED_MODULE_0__.useTexture)(glContext, CELL_TEX_INDEX, 'closeCellIdxsPerCell');\n    gl.texImage2D(// really 1d\n    gl.TEXTURE_2D, 0, // level - irrelevant\n    gl.R32I, // internalFormat - we're using 1 signed 32-bit int for indexes\n    _tex_width_js__WEBPACK_IMPORTED_MODULE_5__.TEX_WIDTH, // width === number of indexes\n    closeCellIdxs_PerCell_Arr.length / _tex_width_js__WEBPACK_IMPORTED_MODULE_5__.TEX_WIDTH, 0, // border - whatever\n    gl.RED_INTEGER, // format\n    gl.INT, // it holds ints\n    closeCellIdxs_PerCell_Arr // texture data\n    );\n    const cellTexLoc = gl.getUniformLocation(programMain.program, \"uCloseCellIdxs\");\n    gl.uniform1i(cellTexLoc, CELL_TEX_INDEX);\n    ///////////////////////////////////////////////\n    ///////////////////////////////////////////////\n    // Create buffer for crossing cell indexes per cell\n    (0,_webgl_utils_use_texture_js__WEBPACK_IMPORTED_MODULE_0__.useTexture)(glContext, CROSS_TEX_INDEX, 'crossCellIdxsPerCell');\n    gl.texImage2D(// really 1d\n    gl.TEXTURE_2D, 0, // level - irrelevant\n    gl.R32I, // internalFormat - we're using 1 signed 32-bit int for indexes\n    _tex_width_js__WEBPACK_IMPORTED_MODULE_5__.TEX_WIDTH, // width === number of indexes\n    crossCellIdxs_PerCell_Arr.length / _tex_width_js__WEBPACK_IMPORTED_MODULE_5__.TEX_WIDTH, // height - linear data texture so we only need height of 1\n    0, // border - whatever\n    gl.RED_INTEGER, // format\n    gl.INT, // it holds ints\n    crossCellIdxs_PerCell_Arr // texture data\n    );\n    const crossTexLoc = gl.getUniformLocation(programMain.program, \"uCrossCellIdxs\");\n    gl.uniform1i(crossTexLoc, CROSS_TEX_INDEX);\n    ///////////////////////////////////////////////\n    if (stretch > 1) {\n        gl.enable(gl.SCISSOR_TEST);\n        gl.scissor(0, 0, width, height / stretch);\n    }\n    gl.viewport(0, 0, width, height);\n    // draw a square colCount * ROW_COUNT times - 6 vertics\n    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, colCount * _row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT);\n    if (stretch > 1) {\n        gl.disable(gl.SCISSOR_TEST);\n    }\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/main-program.ts?\n}")},"./src/max-aspect-ratio-before-stretch.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_ASPECT_RATIO_BEFORE_STRETCH: () => (/* binding */ MAX_ASPECT_RATIO_BEFORE_STRETCH)\n/* harmony export */ });\nconst MAX_ASPECT_RATIO_BEFORE_STRETCH = 4;\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/max-aspect-ratio-before-stretch.ts?\n}")},"./src/prepare-buffers.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prepareBuffers: () => (/* binding */ prepareBuffers)\n/* harmony export */ });\n/* harmony import */ var _bezier_bezier_curves_to_line_segs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier/bezier-curves-to-line-segs.js */ "./src/bezier/bezier-curves-to-line-segs.ts");\n/* harmony import */ var _utils_find_close_cells_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/find-close-cells.js */ "./src/utils/find-close-cells.ts");\n/* harmony import */ var _utils_clip_line_segment_to_grid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/clip-line-segment-to-grid.js */ "./src/utils/clip-line-segment-to-grid.ts");\n/* harmony import */ var _utils_create_empty_grid_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/create-empty-grid.js */ "./src/utils/create-empty-grid.ts");\n/* harmony import */ var _utils_find_crossing_cells_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/find-crossing-cells.js */ "./src/utils/find-crossing-cells.ts");\n/* harmony import */ var _tex_width_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tex-width.js */ "./src/tex-width.ts");\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./row-count.js */ "./src/row-count.ts");\n/* harmony import */ var _utils_clip_line_segment_to_strips_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/clip-line-segment-to-strips.js */ "./src/utils/clip-line-segment-to-strips.ts");\n/* harmony import */ var _utils_map_to_viewbox_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/map-to-viewbox.js */ "./src/utils/map-to-viewbox.ts");\n\n\n\n\n\n\n\n\n\n// import { sum } from \'./utils/sum.js\';  // testing\nfunction prepareBuffers(psss, width, height, colCount, cellSize, maxDistance, padCount, resolution = 0.5, viewbox = [0, 0, width, height], stretch = 1) {\n    ////////////////////////////////////////////////////////////////////////////\n    const psss_ = (0,_utils_map_to_viewbox_js__WEBPACK_IMPORTED_MODULE_8__.mapToViewbox)(viewbox, width, height / stretch, psss);\n    const lineSegs = (0,_bezier_bezier_curves_to_line_segs_js__WEBPACK_IMPORTED_MODULE_0__.bezierCurvesToLineSegs)(psss_, resolution);\n    const grid = (0,_utils_create_empty_grid_js__WEBPACK_IMPORTED_MODULE_3__.createEmptyGrid)(colCount, padCount);\n    const strips = new Array(_row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT).fill(undefined).map(v => []);\n    for (let i = 0; i < lineSegs.length; i++) {\n        const seg = lineSegs[i];\n        // Split the line segment into multiple segments that fit within grid cells\n        (0,_utils_clip_line_segment_to_grid_js__WEBPACK_IMPORTED_MODULE_2__.clipLineSegmentToGrid)(grid, width, height, cellSize, seg, padCount); // add segments to grid\n        (0,_utils_clip_line_segment_to_strips_js__WEBPACK_IMPORTED_MODULE_7__.clipLineSegmentToStrips)(strips, height, seg); // add segments to strips\n    }\n    (0,_utils_find_close_cells_js__WEBPACK_IMPORTED_MODULE_1__.findCloseCells)(grid, colCount, cellSize, maxDistance, padCount); // add close cells\n    (0,_utils_find_crossing_cells_js__WEBPACK_IMPORTED_MODULE_4__.findCrossingCells)(grid, colCount, padCount); // add crossing cells\n    ////////////////////////////////////////////////////////////////////////////\n    const allSegs = [];\n    const segIdxs_PerCell_Range = [];\n    // close cells\n    const closeCellIdxs_PerCell = [];\n    const closeCellIdxs_PerCell_Range = [];\n    // crossing cells\n    const crossCellIdxs_PerCell = [];\n    const crossCellIdxs_PerCell_Range = [];\n    // const closeCellIdxsPerCell_: number[][] = [];  // testing\n    let S1 = 0;\n    let S2 = 0;\n    let S3 = 0;\n    for (let i = 0; i < colCount + 2 * padCount; i++) {\n        for (let j = 0; j < _row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT + 2 * padCount; j++) {\n            const cell = grid[i][j];\n            ///////////\n            if (i >= padCount && i < colCount + padCount &&\n                j >= padCount && j < _row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT + padCount) {\n                const { closeCells, crossingCells } = cell;\n                const L1 = crossingCells.length;\n                crossCellIdxs_PerCell.push(...crossingCells);\n                crossCellIdxs_PerCell_Range.push([S1, L1]);\n                S1 += L1;\n                const L2 = closeCells.length;\n                closeCellIdxs_PerCell.push(...closeCells);\n                closeCellIdxs_PerCell_Range.push([S2, L2]);\n                S2 += L2;\n                // closeCellIdxsPerCell_.push(closeCells);  // testing\n            }\n            //////////\n            const { lineSegs } = cell;\n            const L3 = lineSegs.length;\n            segIdxs_PerCell_Range.push([S3, L3]);\n            S3 += L3;\n            allSegs.push(...lineSegs);\n        }\n    }\n    // It is a requirement to fill in multiples of `TEX_WIDTH`\n    while (closeCellIdxs_PerCell.length % _tex_width_js__WEBPACK_IMPORTED_MODULE_5__.TEX_WIDTH !== 0) {\n        closeCellIdxs_PerCell.push(0);\n    }\n    while (crossCellIdxs_PerCell.length % _tex_width_js__WEBPACK_IMPORTED_MODULE_5__.TEX_WIDTH !== 0) {\n        crossCellIdxs_PerCell.push(0);\n    }\n    // Add line segs from strips\n    const segIdxs_PerStrip_Range = [];\n    for (let i = 0; i < _row_count_js__WEBPACK_IMPORTED_MODULE_6__.ROW_COUNT; i++) {\n        const lineSegs = strips[i];\n        //////////\n        const L = lineSegs.length;\n        segIdxs_PerStrip_Range.push([S3, L]);\n        S3 += L;\n        allSegs.push(...lineSegs);\n    }\n    // all line segments, with their ranges per cell and per strip\n    const lineSegPtCoords_Arr = new Float32Array(allSegs.flat(2));\n    const segIdxs_PerCell_Range_Arr = new Int32Array(segIdxs_PerCell_Range.flat());\n    // close cell idxs and range\n    const closeCellIdxs_PerCell_Range_Arr = new Int32Array(closeCellIdxs_PerCell_Range.flat());\n    const closeCellIdxs_PerCell_Arr = new Int32Array(closeCellIdxs_PerCell);\n    // cross cell idxs and range\n    const crossCellIdxs_PerCell_Arr = new Int32Array(crossCellIdxs_PerCell);\n    const crossCellIdxs_perCell_Range_Arr = new Int32Array(crossCellIdxs_PerCell_Range.flat());\n    // segment index ranges per strip\n    const segIdxs_PerStrip_Range_Arr = new Int32Array(segIdxs_PerStrip_Range.flat());\n    // testing\n    // const r = sum(closeCellIdxsPerCell_.map((c: number[]) => {\n    //     let tot = 0;\n    //     for (let i=0; i<c.length; i++) {\n    //         const idx = c[i];\n    //         const u = Math.trunc(idx / (ROW_COUNT + 2*padCount));\n    //         const v = idx % (ROW_COUNT + 2*padCount);\n    //         tot += grid[u][v].lineSegs.length;\n    //     }\n    //     return tot;\n    // }));\n    // console.log(r, r/colCount/ROW_COUNT);\n    return {\n        lineSegPtCoords_Arr,\n        segIdxs_PerCell_Range_Arr,\n        closeCellIdxs_PerCell_Arr, closeCellIdxs_PerCell_Range_Arr,\n        crossCellIdxs_PerCell_Arr, crossCellIdxs_perCell_Range_Arr,\n        segIdxs_PerStrip_Range_Arr\n    };\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/prepare-buffers.ts?\n}')},"./src/row-count.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ROW_COUNT: () => (/* binding */ ROW_COUNT)\n/* harmony export */ });\n// 32 works by far the best (empirically determined) as compared to e.g. 16 or 64\nconst ROW_COUNT = 32;\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/row-count.ts?\n}")},"./src/shaders/main.fragment.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMainFragment: () => (/* binding */ getMainFragment)\n/* harmony export */ });\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../row-count.js */ \"./src/row-count.ts\");\n\nconst cache = {};\nfunction getMainFragment(colCount, padCount) {\n    const fragment = cache[1024 * colCount + padCount];\n    if (fragment !== undefined) {\n        return fragment;\n    }\n    const main_Fragment = \n    /*glsl*/ `#version 300 es\r\n\r\nprecision highp float;\r\n\r\nuniform float uMaxDistance;\r\nuniform float uExponent;\r\nuniform highp sampler2D uSegs;\r\nuniform highp isampler2D uCloseCellIdxs;\r\nuniform highp isampler2D uCrossCellIdxs;\r\nuniform int uIncl;  // bit 0 -> incl inside, bit 1 -> incl outside\r\n\r\nuniform SegIdxRangePerCellBlock {\r\n    ivec4 uSegIdxRangePerCell[${(_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + 2 * padCount) * (colCount + 2 * padCount) / 2}];\r\n};\r\nuniform SegIdxRangePerStripBlock {\r\n    ivec4 uSegIdxRangePerStrip[${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT / 2}];\r\n};\r\n\r\nin vec2 vXY;\r\nflat in int instanceId;\r\nflat in ivec2 closeCellIdxRange;\r\nflat in ivec2 crossCellIdxRange;\r\nout vec4 FragColor;\r\n\r\n\r\nfloat absDistToSegment(vec2 point, vec2 lineA, vec2 lineB) {\r\n    vec2 lineDir = lineB - lineA;\r\n    float lenSq = dot(lineDir, lineDir);\r\n    float t = clamp(dot(point - lineA, lineDir) / lenSq, 0.0, 1.0);\r\n    vec2 linePt = lineA + t * lineDir;\r\n\r\n    return distance(point, linePt);\r\n}\r\n\r\n\r\nvoid main() {\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    // Project a ray to the left to check if it crosses the segment in order\r\n    // to find the fragment's winding number to determine whether fragment\r\n    // is inside or outside the shape.\r\n\r\n    int crossIdxS = crossCellIdxRange.x;\r\n    int crossLen = crossCellIdxRange.y;\r\n    float winds = 0.0;\r\n    // Iterate over all relevant cell indexes\r\n    for (int i = crossIdxS; i < crossIdxS + crossLen; i++) {\r\n        int crossIdx = texelFetch(uCrossCellIdxs, ivec2(i%256, i/256), 0).x;\r\n\r\n        bool isEven = crossIdx % 2 == 0;\r\n\r\n        ivec4 uSegIdxRange = uSegIdxRangePerCell[crossIdx / 2];\r\n        int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\r\n        int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\r\n\r\n        for (int j = segIdx; j < segIdx + segLen; j++) {\r\n            // Fetch segment from texture\r\n            vec4 seg = texelFetch(uSegs, ivec2(j, 0), 0);\r\n\r\n            // line segment's min-y is excluded\r\n            bool crossing =\r\n                (seg.y > vXY.y != seg.w > vXY.y) &&\r\n                (vXY.x > (seg.z - seg.x)*(vXY.y - seg.y) / (seg.w - seg.y) + seg.x);\r\n\r\n            bool crossingUp = seg.y < seg.w;\r\n\r\n            winds += crossing ? (crossingUp ? 1.0 : -1.0) : 0.0;\r\n        }\r\n    }\r\n\r\n    {\r\n        bool isEven = (instanceId % ${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT}) % 2 == 0;\r\n\r\n        ivec4 uSegIdxRange = uSegIdxRangePerStrip[(instanceId % ${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT}) / 2];\r\n        int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\r\n        int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\r\n\r\n        for (int j = segIdx; j < segIdx + segLen; j++) {\r\n            // Fetch segment from texture\r\n            vec4 seg = texelFetch(uSegs, ivec2(j, 0), 0);\r\n\r\n            // line segment's min-y is excluded\r\n            bool crossing =\r\n                (seg.y > vXY.y != seg.w > vXY.y) &&\r\n                (vXY.x > (seg.z - seg.x)*(vXY.y - seg.y) / (seg.w - seg.y) + seg.x);\r\n\r\n            bool crossingUp = seg.y < seg.w;\r\n\r\n            winds += crossing ? (crossingUp ? 1.0 : -1.0) : 0.0;\r\n        }\r\n    }\r\n\r\n\r\n    bool inside = winds != 0.0;\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    float res = 1.0;  // sdf result\r\n\r\n    if ((inside && (uIncl % 2 != 0)) || (!inside && (uIncl > 1))) {\r\n        int cellIdxS = closeCellIdxRange.x;\r\n        int cellLen = closeCellIdxRange.y;\r\n        // Iterate over all relevant cell indexes\r\n        for (int i = cellIdxS; i < cellIdxS + cellLen; i++) {\r\n            int cellIdx = texelFetch(uCloseCellIdxs, ivec2(i%256, i/256), 0).x;\r\n\r\n            bool isEven = cellIdx % 2 == 0;\r\n            ivec4 uSegIdxRange = uSegIdxRangePerCell[cellIdx / 2];\r\n            int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\r\n            int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\r\n\r\n            for (int j = segIdx; j < segIdx + segLen; j++) {\r\n                // Fetch segment from texture\r\n                vec4 seg = texelFetch(uSegs, ivec2(j, 0), 0);\r\n\r\n                // Find unsigned distance to the segment; only the nearest will be kept\r\n                float d = absDistToSegment(vXY, seg.xy, seg.zw);\r\n                // Apply exponential transform TODO\r\n                // val = pow(1.0 - clamp(d / uMaxDistance, 0.0, 1.0), uExponent) * 0.5;\r\n                float val = clamp(d / uMaxDistance, 0.0, 1.0);\r\n                res = min(res, val);\r\n            }\r\n        }\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n\r\n    // DEBUG!\r\n    float alpha = ((instanceId + instanceId/${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT}) % 2 == 0 ? 0.3 : 0.5);\r\n\r\n    float red = inside ? 0.2 : 0.8;\r\n    float green = abs(sin(50.0 * res));\r\n    float blue = 0.5;\r\n    // float alpha = inside ? 0.5 : 0.0;\r\n\r\n    FragColor = vec4(red, green, blue, alpha);\r\n}\r\n`;\n    cache[1024 * colCount + padCount] = main_Fragment;\n    return main_Fragment;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/shaders/main.fragment.ts?\n}")},"./src/shaders/main.vertex.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   main_Vertex: () => (/* binding */ main_Vertex)\n/* harmony export */ });\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../row-count.js */ "./src/row-count.ts");\n\nconst main_Vertex = /*glsl*/ `#version 300 es\r\n\r\nprecision highp float;\r\n\r\nuniform vec2 uWidthHeight;\r\nin vec2 aUV;\r\nin ivec2 aCloseCellIdxRangePerCell;\r\nin ivec2 aCrossIdxRangePerCell;\r\nout vec2 vXY;\r\nflat out int instanceId;\r\nflat out ivec2 closeCellIdxRange;\r\nflat out ivec2 crossCellIdxRange;\r\n\r\n\r\nvoid main() {\r\n    instanceId = gl_InstanceID;\r\n    closeCellIdxRange = aCloseCellIdxRangePerCell;\r\n    crossCellIdxRange = aCrossIdxRangePerCell;\r\n\r\n    // drawn column-by-column\r\n    float i = float(instanceId / ${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT});  // column index\r\n    float j = float(instanceId % ${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT});  // row index\r\n\r\n    vec2 trans = vec2(\r\n        i / float(${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT}),\r\n        j / float(${_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT})\r\n    );\r\n\r\n    vec2 uv = aUV + trans;\r\n\r\n    float width = uWidthHeight.x;\r\n    float height = uWidthHeight.y;\r\n\r\n    vXY = vec2(\r\n        height * uv.x,\r\n        height * uv.y\r\n    );\r\n\r\n    float aspectRatio = width / height;\r\n\r\n    gl_Position = vec4(\r\n        vec2(\r\n            (2.0*(uv.x / aspectRatio) - 1.0),\r\n            2.0*uv.y - 1.0\r\n        ),\r\n        0.0, 1.0\r\n    );\r\n}\r\n`;\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/shaders/main.vertex.ts?\n}')},"./src/svg/get-beziers-from-raw-paths.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBeziersFromRawPaths: () => (/* binding */ getBeziersFromRawPaths)\n/* harmony export */ });\n/* harmony import */ var _path_segment_z_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path-segment/z.js */ "./src/svg/path-segment/z.ts");\n/* harmony import */ var _path_segment_c_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-segment/c.js */ "./src/svg/path-segment/c.ts");\n/* harmony import */ var _path_segment_s_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path-segment/s.js */ "./src/svg/path-segment/s.ts");\n/* harmony import */ var _path_segment_l_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path-segment/l.js */ "./src/svg/path-segment/l.ts");\n/* harmony import */ var _path_segment_h_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path-segment/h.js */ "./src/svg/path-segment/h.ts");\n/* harmony import */ var _path_segment_v_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path-segment/v.js */ "./src/svg/path-segment/v.ts");\n/* harmony import */ var _path_segment_q_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./path-segment/q.js */ "./src/svg/path-segment/q.ts");\n/* harmony import */ var _path_segment_t_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path-segment/t.js */ "./src/svg/path-segment/t.ts");\n\n\n\n\n\n\n\n\nconst pathFs = {\n    c: _path_segment_c_js__WEBPACK_IMPORTED_MODULE_1__.c, // cubic bezier\n    h: _path_segment_h_js__WEBPACK_IMPORTED_MODULE_4__.h, // horizontal line\n    l: _path_segment_l_js__WEBPACK_IMPORTED_MODULE_3__.l, // line\n    q: _path_segment_q_js__WEBPACK_IMPORTED_MODULE_6__.q, // quadratic bezier\n    s: _path_segment_s_js__WEBPACK_IMPORTED_MODULE_2__.s, // cubic bezier (smooth)\n    t: _path_segment_t_js__WEBPACK_IMPORTED_MODULE_7__.t, // quadratic bezier (smooth)\n    v: _path_segment_v_js__WEBPACK_IMPORTED_MODULE_5__.v, // vertical line\n    z: _path_segment_z_js__WEBPACK_IMPORTED_MODULE_0__.z // close path\n};\n/**\n * Returns order 1, 2 and 3 beziers from the given SVG DOM element. If a path\n * data tag is not "C, Q or L, etc", i.e. if it is not an absolute bezier\n * coordinate then it is converted into one.\n *\n * @param paths An SVG element\n */\nfunction getBeziersFromRawPaths(paths) {\n    if (paths.length === 0) {\n        return []; // A shape is not described   \n    }\n    if (paths[0].type.toLowerCase() !== \'m\') {\n        throw new Error(\'Invalid SVG - every new path must start with an M or m.\');\n    }\n    const s = { p: [0, 0] };\n    const beziersArrays = [];\n    let beziers = [];\n    let prevType = undefined;\n    for (let i = 0; i < paths.length; i++) {\n        const pathSeg = paths[i];\n        const type = pathSeg.type.toLowerCase();\n        s.vals = pathSeg.values;\n        // If pathSeg was lowercase, it is relative - make absolute\n        if (pathSeg.type === type) {\n            if (type === \'v\') {\n                s.vals[0] += s.p[1];\n            }\n            else if (type === \'a\') {\n                s.vals[5] += s.p[0];\n                s.vals[6] += s.p[1];\n            }\n            else {\n                for (let i = 0; i < s.vals.length; i++) {\n                    s.vals[i] += s.p[i % 2];\n                }\n            }\n        }\n        if (type === \'m\') {\n            if (beziers.length) {\n                // This is a subpath, close as if the previous command was a \n                // Z or z.\n                if (prevType !== \'z\') {\n                    beziers.push((0,_path_segment_z_js__WEBPACK_IMPORTED_MODULE_0__.z)(s));\n                }\n                // Start new path\n                beziersArrays.push(beziers);\n                beziers = [];\n            }\n            s.initialPoint = s.p = s.vals;\n            prevType = type;\n            continue;\n        }\n        const f = pathFs[type];\n        if (!f) {\n            throw new Error(\'Invalid SVG - command not recognized.\');\n        }\n        const ps = f(s);\n        s.p = ps[ps.length - 1]; // Update current point\n        beziers.push(ps);\n        prevType = type;\n    }\n    if (beziers.length > 0) {\n        // This is a subpath, close as if the previous command was a Z or z.\n        if (prevType !== \'z\') {\n            beziers.push((0,_path_segment_z_js__WEBPACK_IMPORTED_MODULE_0__.z)(s));\n        }\n        // Start new path\n        beziersArrays.push(beziers);\n    }\n    return beziersArrays;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/get-beziers-from-raw-paths.ts?\n}')},"./src/svg/get-paths-from-str.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPathsFromStr: () => (/* binding */ getPathsFromStr)\n/* harmony export */ });\n/* harmony import */ var _get_beziers_from_raw_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-beziers-from-raw-paths.js */ "./src/svg/get-beziers-from-raw-paths.ts");\n/* harmony import */ var _path_data_polyfill_parse_path_data_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path-data-polyfill/parse-path-data-string.js */ "./src/svg/path-data-polyfill/parse-path-data-string.ts");\n\n\n/**\n * Returns an array of loops with each loop consisting of an array of beziers\n * and each bezier in turn consisting of an array of control points from the\n * given SVG path string. An array of loops are returned (as opposed to a single\n * loop) since an SVG path may have sub-paths.\n * @param str The SVG path string, e.g. \'M1 1 C 5 1 5 2 4 2 C 3 3 1 3 1 1 z\'\n */\nfunction getPathsFromStr(str) {\n    return (0,_get_beziers_from_raw_paths_js__WEBPACK_IMPORTED_MODULE_0__.getBeziersFromRawPaths)((0,_path_data_polyfill_parse_path_data_string_js__WEBPACK_IMPORTED_MODULE_1__.parsePathDataString)(str));\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/get-paths-from-str.ts?\n}')},"./src/svg/path-data-polyfill/parse-number.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseNumber: () => (/* binding */ parseNumber)\n/* harmony export */ });\n/**\n * @hidden\n * Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n * Source/core/svg/SVGParserUtilities.cpp.\n * Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n * @param source\n */\nfunction parseNumber(source) {\n    let exponent = 0;\n    let integer = 0;\n    let frac = 1;\n    let decimal = 0;\n    let sign = 1;\n    let expsign = 1;\n    const startIndex = source._currentIndex;\n    source._skipOptionalSpaces();\n    // Read the sign.\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === "+") {\n        source._currentIndex += 1;\n    }\n    else if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === "-") {\n        source._currentIndex += 1;\n        sign = -1;\n    }\n    if (source._currentIndex === source._endIndex ||\n        ((source._string[source._currentIndex] < "0" || source._string[source._currentIndex] > "9") &&\n            source._string[source._currentIndex] !== ".")) {\n        throw new Error(\'The first character of a number must be one of [0-9+-.].\');\n    }\n    // Read the integer part, build right-to-left.\n    const startIntPartIndex = source._currentIndex;\n    while (source._currentIndex < source._endIndex &&\n        source._string[source._currentIndex] >= "0" &&\n        source._string[source._currentIndex] <= "9") {\n        source._currentIndex += 1; // Advance to first non-digit.\n    }\n    if (source._currentIndex !== startIntPartIndex) {\n        let scanIntPartIndex = source._currentIndex - 1;\n        let multiplier = 1;\n        while (scanIntPartIndex >= startIntPartIndex) {\n            integer += multiplier * (Number(source._string[scanIntPartIndex]) - 0);\n            scanIntPartIndex -= 1;\n            multiplier *= 10;\n        }\n    }\n    // Read the decimals.\n    if (source._currentIndex < source._endIndex && source._string[source._currentIndex] === ".") {\n        source._currentIndex += 1;\n        if (source._currentIndex >= source._endIndex ||\n            source._string[source._currentIndex] < "0" ||\n            source._string[source._currentIndex] > "9") {\n            throw new Error(\'There must be a least one digit following the .\');\n        }\n        while (source._currentIndex < source._endIndex &&\n            source._string[source._currentIndex] >= "0" &&\n            source._string[source._currentIndex] <= "9") {\n            frac *= 10;\n            decimal += (Number(source._string.charAt(source._currentIndex))) / frac;\n            source._currentIndex += 1;\n        }\n    }\n    // Read the exponent part.\n    if (source._currentIndex !== startIndex &&\n        source._currentIndex + 1 < source._endIndex &&\n        (source._string[source._currentIndex] === "e" || source._string[source._currentIndex] === "E") &&\n        (source._string[source._currentIndex + 1] !== "x" && source._string[source._currentIndex + 1] !== "m")) {\n        source._currentIndex += 1;\n        // Read the sign of the exponent.\n        if (source._string[source._currentIndex] === "+") {\n            source._currentIndex += 1;\n        }\n        else if (source._string[source._currentIndex] === "-") {\n            source._currentIndex += 1;\n            expsign = -1;\n        }\n        if (source._currentIndex >= source._endIndex ||\n            source._string[source._currentIndex] < "0" ||\n            source._string[source._currentIndex] > "9") {\n            throw new Error(\'There must be an exponent.\');\n        }\n        while (source._currentIndex < source._endIndex &&\n            source._string[source._currentIndex] >= "0" &&\n            source._string[source._currentIndex] <= "9") {\n            exponent *= 10;\n            exponent += (Number(source._string[source._currentIndex]));\n            source._currentIndex += 1;\n        }\n    }\n    let number = integer + decimal;\n    number *= sign;\n    if (exponent) {\n        number *= Math.pow(10, expsign * exponent);\n    }\n    if (startIndex === source._currentIndex) {\n        throw new Error(\'Internal error: startIndex === source._currentIndex\');\n    }\n    source._skipOptionalSpacesOrDelimiter();\n    return number;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-data-polyfill/parse-number.ts?\n}')},"./src/svg/path-data-polyfill/parse-path-data-string.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePathDataString: () => (/* binding */ parsePathDataString)\n/* harmony export */ });\n/* harmony import */ var _source_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./source.js */ \"./src/svg/path-data-polyfill/source.ts\");\n\n/**\n * @hidden\n * @param string\n */\nfunction parsePathDataString(string) {\n    if (!string.length) {\n        return [];\n    }\n    const source = new _source_js__WEBPACK_IMPORTED_MODULE_0__.Source(string);\n    const pathData = [];\n    if (!source.initialCommandIsMoveTo()) {\n        throw new Error('Path must start with m or M');\n    }\n    while (source.hasMoreData()) {\n        pathData.push(source.parseSegment());\n    }\n    return pathData;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-data-polyfill/parse-path-data-string.ts?\n}")},"./src/svg/path-data-polyfill/source.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Source: () => (/* binding */ Source)\n/* harmony export */ });\n/* harmony import */ var _parse_number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-number.js */ "./src/svg/path-data-polyfill/parse-number.ts");\n\n/** @hidden */\nconst COMMAND_MAP = {\n    Z: "Z", M: "M", L: "L", C: "C", Q: "Q", A: "A", H: "H", V: "V", S: "S", T: "T",\n    z: "Z", m: "m", l: "l", c: "c", q: "q", a: "a", h: "h", v: "v", s: "s", t: "t"\n};\n/** @hidden */\nclass Source {\n    _string;\n    _currentIndex;\n    _endIndex;\n    _prevCommand;\n    constructor(string) {\n        this._string = string;\n        this._currentIndex = 0;\n        this._endIndex = this._string.length;\n        this._prevCommand = undefined;\n        this._skipOptionalSpaces();\n    }\n    parseSegment() {\n        const char = this._string[this._currentIndex];\n        let command = COMMAND_MAP[char];\n        if (command === undefined) {\n            if (this._prevCommand === undefined) {\n                throw new Error(\'Implicit command not allowed for first commands.\');\n            }\n            // Check for remaining coordinates in the current command.\n            if ((char === "+" || char === "-" || char === "." || (char >= "0" && char <= "9")) &&\n                this._prevCommand !== "Z") {\n                if (this._prevCommand === "M") {\n                    command = "L";\n                }\n                else if (this._prevCommand === "m") {\n                    command = "l";\n                }\n                else {\n                    command = this._prevCommand;\n                }\n            }\n            else {\n                throw new Error(\'Remaining coordinates not found for implicit command\');\n            }\n        }\n        else {\n            this._currentIndex += 1;\n        }\n        this._prevCommand = command;\n        let values = undefined;\n        const cmd = command.toUpperCase();\n        if (cmd === "H" || cmd === "V") {\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\n        }\n        else if (cmd === "M" || cmd === "L" || cmd === "T") {\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\n        }\n        else if (cmd === "S" || cmd === "Q") {\n            values = [(0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this), (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)];\n        }\n        else if (cmd === "C") {\n            values = [\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)\n            ];\n        }\n        else if (cmd === "A") {\n            values = [\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                this._parseArcFlag(),\n                this._parseArcFlag(),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this),\n                (0,_parse_number_js__WEBPACK_IMPORTED_MODULE_0__.parseNumber)(this)\n            ];\n        }\n        else if (cmd === "Z") {\n            this._skipOptionalSpaces();\n            values = [];\n        }\n        if (values === undefined) {\n            throw new Error(\'Unknown command\');\n        }\n        else {\n            return { type: command, values };\n        }\n    }\n    hasMoreData() {\n        return this._currentIndex < this._endIndex;\n    }\n    initialCommandIsMoveTo() {\n        // If the path is empty it is still valid, so return true.\n        if (!this.hasMoreData()) {\n            return true;\n        }\n        const command = COMMAND_MAP[this._string[this._currentIndex]];\n        return command === "M" || command === "m";\n    }\n    _isCurrentSpace() {\n        const char = this._string[this._currentIndex];\n        return char <= " " && (char === " " || char === "\\n" || char === "\\t" || char === "\\r" || char === "\\f");\n    }\n    _skipOptionalSpaces() {\n        while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n            this._currentIndex += 1;\n        }\n        return this._currentIndex < this._endIndex;\n    }\n    _skipOptionalSpacesOrDelimiter() {\n        if (this._currentIndex < this._endIndex &&\n            !this._isCurrentSpace() &&\n            this._string[this._currentIndex] !== ",") {\n            return false;\n        }\n        if (this._skipOptionalSpaces()) {\n            if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === ",") {\n                this._currentIndex += 1;\n                this._skipOptionalSpaces();\n            }\n        }\n        return this._currentIndex < this._endIndex;\n    }\n    _parseArcFlag() {\n        if (this._currentIndex >= this._endIndex) {\n            throw new Error(\'Unable to parse arc flag\');\n        }\n        let flag = undefined;\n        const flagChar = this._string[this._currentIndex];\n        this._currentIndex += 1;\n        if (flagChar === "0") {\n            flag = 0;\n        }\n        else if (flagChar === "1") {\n            flag = 1;\n        }\n        else {\n            throw new Error(\'Unable to parse arc flag - arc flag must be 0 or 1\');\n        }\n        this._skipOptionalSpacesOrDelimiter();\n        return flag;\n    }\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-data-polyfill/source.ts?\n}')},"./src/svg/path-segment/c.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ c)\n/* harmony export */ });\n/**\n * @hidden\n * C and c: (from www.w3.org)\n *\n * params: x1 y1 x2 y2 x y\n *\n * Draws a cubic Bézier curve from the current point to (x,y)\n * using (x1,y1) as the control point at the beginning of the\n * curve and (x2,y2) as the control point at the end of the\n * curve. C (uppercase) indicates that absolute coordinates\n * will follow; c (lowercase) indicates that relative\n * coordinates will follow. Multiple sets of coordinates may\n * be specified to draw a polybézier. At the end of the\n * command, the new current point becomes the final (x,y)\n * coordinate pair used in the polybézier.\n */\nfunction c(s) {\n    const ps = [\n        s.p,\n        [s.vals[0], s.vals[1]],\n        [s.vals[2], s.vals[3]],\n        [s.vals[4], s.vals[5]]\n    ];\n    s.prev2ndCubicControlPoint = ps[2];\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/c.ts?\n}")},"./src/svg/path-segment/h.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ h)\n/* harmony export */ });\n/**\n * @hidden\n * H and h: (from www.w3.org)\n *\n * params: x\n *\n * Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H\n * (uppercase) indicates that absolute coordinates will follow; h (lowercase)\n * indicates that relative coordinates will follow. Multiple x values can be\n * provided (although usually this doesn't make sense). At the end of the\n * command, the new current point becomes (x, cpy) for the final value of x.\n */\nfunction h(s) {\n    const ps = [\n        s.p,\n        [s.vals[0], s.p[1]]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/h.ts?\n}")},"./src/svg/path-segment/l.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ l)\n/* harmony export */ });\n/**\n * @hidden\n * L and l: (from www.w3.org)\n *\n * params: x y\n *\n * Draw a line from the current point to the given (x,y) coordinate which\n * becomes the new current point. L (uppercase) indicates that absolute\n * coordinates will follow; l (lowercase) indicates that relative coordinates\n * will follow. A number of coordinates pairs may be specified to draw a\n * polyline. At the end of the command, the new current point is set to the\n * final set of coordinates provided.\n */\nfunction l(s) {\n    const ps = [\n        s.p,\n        s.vals\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/l.ts?\n}")},"./src/svg/path-segment/q.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   q: () => (/* binding */ q)\n/* harmony export */ });\n/**\n * @hidden\n * Q and q: (from www.w3.org)\n *\n * params: x1 y1 x y\n *\n * Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1)\n * as the control point. Q (uppercase) indicates that absolute coordinates will\n * follow; q (lowercase) indicates that relative coordinates will follow.\n * Multiple sets of coordinates may be specified to draw a polybézier. At the\n * end of the command, the new current point becomes the final (x,y) coordinate\n * pair used in the polybézier.\n */\nfunction q(s) {\n    const QP1 = [s.vals[0], s.vals[1]];\n    const QP2 = [s.vals[2], s.vals[3]];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = QP1;\n    const ps = [s.p, QP1, QP2];\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/q.ts?\n}")},"./src/svg/path-segment/s.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   s: () => (/* binding */ s)\n/* harmony export */ });\n/**\n * @hidden\n * S and s: (from www.w3.org)\n *\n * params: x2 y2 x y\n *\n * Draws a cubic Bézier curve from the current point to (x,y). The first control\n * point is assumed to be the reflection of the second control point on the\n * previous command relative to the current point. (If there is no previous\n * command or if the previous command was not an C, c, S or s, assume the first\n * control point is coincident with the current point.) (x2,y2) is the second\n * control point (i.e., the control point at the end of the curve). S\n * (uppercase) indicates that absolute coordinates will follow; s (lowercase)\n * indicates that relative coordinates will follow. Multiple sets of coordinates\n * may be specified to draw a polybézier. At the end of the command, the new\n * current point becomes the final (x,y) coordinate pair used in the polybézier.\n */\nfunction s(s) {\n    const p = s.prev2ndCubicControlPoint\n        ? [(s.p[0] - s.prev2ndCubicControlPoint[0]) + s.p[0],\n            (s.p[1] - s.prev2ndCubicControlPoint[1]) + s.p[1]]\n        : s.p;\n    const ps = [\n        s.p,\n        p,\n        [s.vals[0], s.vals[1]],\n        [s.vals[2], s.vals[3]]\n    ];\n    s.prev2ndCubicControlPoint = ps[2];\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/s.ts?\n}")},"./src/svg/path-segment/t.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   t: () => (/* binding */ t)\n/* harmony export */ });\n/**\n * @hidden\n * T and t: (from www.w3.org)\n *\n * params: x y\n *\n * Draws a quadratic Bézier curve from the current point to (x,y). The control\n * point is assumed to be the reflection of the control point on the previous\n * command relative to the current point. (If there is no previous command or if\n * the previous command was not a Q, q, T or t, assume the control point is\n * coincident with the current point.) T (uppercase) indicates that absolute\n * coordinates will follow; t (lowercase) indicates that relative coordinates\n * will follow. At the end of the command, the new current point becomes the\n * final (x,y) coordinate pair used in the polybézier.\n */\nfunction t(s) {\n    const p = s.prev2ndQuadraticControlPoint\n        ? [(s.p[0] - s.prev2ndQuadraticControlPoint[0]) + s.p[0],\n            (s.p[1] - s.prev2ndQuadraticControlPoint[1]) + s.p[1]]\n        : s.p;\n    const QP1 = p;\n    const QP2 = [s.vals[0], s.vals[1]];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = QP1;\n    return [s.p, QP1, QP2];\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/t.ts?\n}")},"./src/svg/path-segment/v.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ v)\n/* harmony export */ });\n/**\n * @hidden\n * V and v: (from www.w3.org)\n *\n * params: y\n *\n * Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V\n * (uppercase) indicates that absolute coordinates will follow; v (lowercase)\n * indicates that relative coordinates will follow. Multiple y values can be\n * provided (although usually this doesn't make sense). At the end of the\n * command, the new current point becomes (cpx, y) for the final value of y.\n */\nfunction v(s) {\n    const ps = [\n        s.p,\n        [s.p[0], s.vals[0]]\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/v.ts?\n}")},"./src/svg/path-segment/z.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\n/**\n * @hidden\n * Z and z: (from www.w3.org)\n *\n * params: (none)\n *\n * Close the current subpath by drawing a straight line from the current point\n * to current subpath's initial point. Since the Z and z commands take no\n * parameters, they have an identical effect.\n */\nfunction z(s) {\n    const ps = [\n        s.p,\n        s.initialPoint\n    ];\n    s.prev2ndCubicControlPoint = undefined;\n    s.prev2ndQuadraticControlPoint = undefined;\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/svg/path-segment/z.ts?\n}")},"./src/tex-width.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TEX_WIDTH: () => (/* binding */ TEX_WIDTH)\n/* harmony export */ });\n/**\n * Just a general texture width for our textures holding general data.\n * * width cannot be too small otherwise width or height might exceed\n * `gl.getParameter(gl.MAX_TEXTURE_SIZE)`\n * * if width is too large we might need to pad too many zeros so `256` is a\n * good balance since we are guaranteed at least 4096 for MAX_TEXTURE_SIZE\n * so we can store 256 * 4096 = 1_048_576 values per texture, more than\n * adequate for our purposes\n */\nconst TEX_WIDTH = 256;\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/tex-width.ts?\n}")},"./src/utils/calc-circs.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circsCache: () => (/* binding */ circsCache)\n/* harmony export */ });\n/* harmony import */ var _max_aspect_ratio_before_stretch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../max-aspect-ratio-before-stretch.js */ "./src/max-aspect-ratio-before-stretch.ts");\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../row-count.js */ "./src/row-count.ts");\n/* harmony import */ var _vector_len_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vector/len.js */ "./src/vector/len.ts");\n\n\n\n/**\n * Represents the max distance (in cell side length units) from one corner of\n * the viewbox to the opposing corner.\n */\n// const diagLen = ceil(sqrt((MAX_ASPECT_RATIO_BEFORE_STRETCH*ROW_COUNT)**2 + ROW_COUNT**2));\nconst circsCache = calcCircs();\nfunction calcCircs() {\n    const ranges = [{ from: 0, u: 0, v: 0 }];\n    // for (let i=0; i<ROW_COUNT; i++) {\n    for (let i = 0; i < _max_aspect_ratio_before_stretch_js__WEBPACK_IMPORTED_MODULE_0__.MAX_ASPECT_RATIO_BEFORE_STRETCH * _row_count_js__WEBPACK_IMPORTED_MODULE_1__.ROW_COUNT; i++) {\n        ranges.push({ from: i + 0.5, u: i + 1, v: 0 });\n        ranges.push({ from: i + 0.5, u: -i - 1, v: 0 });\n        ranges.push({ from: i + 0.5, u: 0, v: i + 1 });\n        ranges.push({ from: i + 0.5, u: 0, v: -i - 1 });\n        for (let j = 0; j < _row_count_js__WEBPACK_IMPORTED_MODULE_1__.ROW_COUNT; j++) {\n            const p = [0.5 + i, 0.5 + j];\n            const d = (0,_vector_len_js__WEBPACK_IMPORTED_MODULE_2__.len)(p);\n            const u = i + 1;\n            const v = j + 1;\n            ranges.push({ from: d, u, v });\n            if (u !== 0) {\n                ranges.push({ from: d, u: -u, v });\n            }\n            if (v !== 0) {\n                ranges.push({ from: d, u, v: -v });\n            }\n            if (u !== 0 && v !== 0) {\n                ranges.push({ from: d, u: -u, v: -v });\n            }\n        }\n        ranges.sort((a, b) => (a.from - b.from));\n    }\n    return ranges;\n}\n\n// Quokka tests\n// const { E, trunc, max, sqrt, ceil } = Math;\n// calcCircs().length;//?\n// const cs = calcCircs().map(c => c.from);\n// const longest = (() => {\n//     let l = 0;\n//     let maxL = 0;\n//     let _v = 0;\n//     for (let i=0; i<cs.length; i++) {\n//         const v = cs[i];\n//         if (_v === cs[i]) {\n//             l++;\n//         } else {\n//             l = 0;\n//         }\n//         _v = v;\n//         if (l > maxL) {\n//             maxL = l;\n//         }\n//     }\n//     return maxL;\n// })();//?\n// const froms = [\n//     { from: 0, to: 50, skip: 1 },\n//     { from: 50, to: 3050, skip: 50 },\n//     { from: 400, to: 4000, skip: 100 },\n//     // { from: 10, to: 100, skip: 10 }\n// ];\n// for (let j=0; j<froms.length; j++) {\n//     const { from, to, skip } = froms[j];\n//     let strs: string[] = [];\n//     for (let i=from; i<to; i += skip) {\n//         const v = cs[i];\n//         strs.push(`${v.toString()}\t${i}`);\n//     }\n//     const csStr = strs.join(\'\\n\');\n//     console.log(csStr);\n// }\n// jumpIdx(3.7);//?\n// for (let i=30; i<44; i += 0.25) {\n//     jumpIdx(i);//?\n//     [(cs[jumpIdx(i)]), i];//?\n// }\n// let tot = 0;\n// const vs: number[] = [];\n// for (let i=400; i<=3800; i++) {\n// \tconst c = cs[i];\n// \tconst ap = A*(E**(B*c)) + C*(E**(-D*c)) + F;\n// \tconst S = B*A*(E**(B*c)) + -D*C*(E**(-D*c));\n// \t// i;//?\n// \t// ap;//?\n// \tconst err = abs(i - ap);\n// \ttot += err;\n// \tvs.push(err);\n// }\n// vs.sort((a,b) => b - a);//?\n// vs[3400];//?\n// tot/(3800 - 400);//?\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/calc-circs.ts?\n}')},"./src/utils/clip-line-segment-to-grid.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clipLineSegmentToGrid: () => (/* binding */ clipLineSegmentToGrid)\n/* harmony export */ });\n/* harmony import */ var _seg_box_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./seg-box-x.js */ "./src/utils/seg-box-x.ts");\n\nconst { floor, ceil } = Math;\n/**\n * Clips a line segment to grid boundaries and returns multiple segments.\n *\n * * modifies grid by adding line segments to cells\n * * size/count *must* be a power of 2\n *\n * @param count the number of grid cells per dimension\n * @param width\n * @param height\n * @param seg the line segment (array of 2 points)\n */\nfunction clipLineSegmentToGrid(grid, width, height, cellSize, seg, padCount) {\n    const padding = cellSize * padCount;\n    const [[x0, y0], [x1, y1]] = seg;\n    const paddedWidth = width + padding;\n    const paddedHeight = height + padding;\n    const ps = (0,_seg_box_x_js__WEBPACK_IMPORTED_MODULE_0__.segBoxX)(seg, [[-padding, -padding], [paddedWidth, paddedHeight]]);\n    const p0IsInBox = x0 > -padding && x0 < paddedWidth && y0 > -padding && y0 < paddedHeight;\n    const p1IsInBox = x1 > -padding && x1 < paddedWidth && y1 > -padding && y1 < paddedHeight;\n    // if line is completely outside box\n    if (ps.length < 2 && !p0IsInBox && !p1IsInBox) {\n        return;\n    }\n    // Determine which grid cells the line passes through\n    const dX = x1 - x0;\n    const dY = y1 - y0;\n    // Use Bresenham-like approach to find all grid cells the line crosses\n    const stepX = x1 > x0 ? cellSize : -cellSize;\n    const stepY = y1 > y0 ? cellSize : -cellSize;\n    /** first point of each line segment to connect */\n    /** current x position */\n    let x = x0;\n    /** current y position */\n    let y = y0;\n    // current intersection index\n    let xIdx = 0;\n    // left-to-right\n    const ltr = stepX > 0;\n    // bottom-to-top\n    const btt = stepY > 0;\n    // // line segment min-y excluded\n    // const crossing =\n    //     (seg.y > y != seg.w > y) &&\n    //     (x > (seg.z - seg.x)*(y - seg.y) / (seg.w - seg.y) + seg.x);\n    const fX = ltr ? floor : ceil;\n    const fY = btt ? floor : ceil;\n    while (true) {\n        // Find next grid boundary\n        let nextGridX = cellSize * fX((x + stepX) / cellSize);\n        let nextGridY = cellSize * fY((y + stepY) / cellSize);\n        // Calculate parameter t for intersection with vertical and horizontal grid lines\n        // eq. (1)\n        const tX = (nextGridX - x0) / dX;\n        // eq. (2)\n        const tY = (nextGridY - y0) / dY;\n        const useTx = (tX < tY && dX !== 0) || dY === 0;\n        /** intersection X */\n        const xX = useTx ? nextGridX : x0 + tY * dX;\n        /** intersection Y */\n        const xY = useTx ? y0 + tX * dY : nextGridY;\n        // if we\'re past the line endpoint\n        if ((tX > 1 || dX === 0) && (tY > 1 || dY === 0)) {\n            const u = floor(x1 / cellSize) + padCount;\n            const v = floor(y1 / cellSize) + padCount;\n            grid[u]?.[v]?.lineSegs.push([[x, y], [x1, y1]]);\n            break;\n        }\n        // if next grid intersection is on edge of grid\n        if ((xX <= -padding || xY <= -padding) || (xX >= paddedWidth || xY >= paddedHeight)) {\n            const entering = !p0IsInBox && xIdx === 0;\n            if (entering) {\n                [x, y] = ps[0]; // update current x,y position\n                xIdx++;\n                continue;\n            }\n            else {\n                const u = fX(x / cellSize) - (ltr ? 0 : 1) + padCount; // current u\n                const v = fY(y / cellSize) - (btt ? 0 : 1) + padCount; // current v\n                const seg_ = [[x, y], ps[xIdx]];\n                grid[u]?.[v]?.lineSegs.push(seg_);\n                break;\n            }\n        }\n        const u = fX(x / cellSize) - (ltr ? 0 : 1) + padCount; // current u\n        const v = fY(y / cellSize) - (btt ? 0 : 1) + padCount; // current v\n        grid[u]?.[v]?.lineSegs.push([[x, y], [xX, xY]]);\n        // update current position\n        x = xX;\n        y = xY;\n    }\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/clip-line-segment-to-grid.ts?\n}')},"./src/utils/clip-line-segment-to-strips.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clipLineSegmentToStrips: () => (/* binding */ clipLineSegmentToStrips)\n/* harmony export */ });\n/* harmony import */ var _seg_strip_x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./seg-strip-x.js */ "./src/utils/seg-strip-x.ts");\n\nconst { floor, ceil } = Math;\n/**\n * Clips a line segment to strip boundaries and returns multiple segments.\n *\n * * modifies strips by adding line segments to each strip\n * * size/count *must* be a power of 2\n *\n * @param strips array of strips - each contains an array line segments\n * @param height the height of a strip\n * @param seg the line segment (array of 2 points)\n */\nfunction clipLineSegmentToStrips(strips, height, seg) {\n    const count = strips.length;\n    /** `cellSize` *must* be a power of two */\n    const cellSize = height / count;\n    const [p0, p1] = seg;\n    const ps = (0,_seg_strip_x_js__WEBPACK_IMPORTED_MODULE_0__.segStripX)(seg, [0, 0, height]);\n    const [x0, y0] = p0;\n    const [x1, y1] = p1;\n    const dX = x1 - x0;\n    const dY = y1 - y0;\n    const p0IsInStrip = x0 < 0 && y0 > 0 && y0 < height;\n    const p1IsInStrip = x1 < 0 && y1 > 0 && y1 < height;\n    // if line is completely outside strip\n    if ((ps.length < 2 && !p0IsInStrip && !p1IsInStrip) &&\n        ((x0 !== 0 || dX !== 0) ||\n            ((y0 <= 0 && y1 <= 0) || (y0 >= height && y1 >= height)))) {\n        return;\n    }\n    // Determine which strips the line passes through\n    if (dY === 0) { // no crossings possible\n        return;\n    }\n    // Use Bresenham-like approach to find all strips the line crosses\n    const stepY = y1 > y0 ? cellSize : -cellSize;\n    /** first point of each line segment to connect */\n    /** current x position */\n    let x = x0;\n    /** current y position */\n    let y = y0;\n    let i = 0;\n    // left-to-right\n    const ltr = x1 > x0;\n    // bottom-to-top\n    const btt = y1 > y0;\n    // // line segment min-y excluded\n    // const crossing =\n    //     (seg.y > y != seg.w > y) &&\n    //     (x > (seg.z - seg.x)*(y - seg.y) / (seg.w - seg.y) + seg.x);\n    const fY = btt ? floor : ceil;\n    while (true) {\n        // Find next strip boundary\n        let nextGridX = ((ltr && x < 0) || (!ltr && x > 0)) ? 0 : Number.NEGATIVE_INFINITY;\n        let nextGridY = cellSize * fY((y + stepY) / cellSize);\n        // Calculate parameter t for intersection with horizontal strip lines\n        // eq. (1)\n        const tX = (nextGridX - x0) / dX;\n        // eq. (2)\n        const tY = (nextGridY - y0) / dY;\n        const useTx = tX < tY && dX !== 0;\n        /** intersection X */\n        const xX = useTx ? 0 : x0 + tY * dX;\n        /** intersection Y */\n        const xY = useTx ? y0 + tX * dY : nextGridY;\n        // if we\'re past the line endpoint\n        if ((tX > 1 || dX === 0) && tY > 1) {\n            const v = floor(p1[1] / cellSize);\n            strips[v]?.push([[x, y], p1]);\n            break;\n        }\n        if (((xX >= 0 && (x0 !== 0 || dX !== 0)) || xY <= 0 || xY >= height)) {\n            // next strip intersection is on edge of strips\n            const entering = !p0IsInStrip && i === 0;\n            if (entering) {\n                // update current x,y position\n                [x, y] = ps[0];\n                i++;\n                continue;\n            }\n            else {\n                const v = fY(y / cellSize) - (btt ? 0 : 1); // previous v\n                const seg_ = [[x, y], ps[i]];\n                strips[v]?.push(seg_);\n                break;\n            }\n        }\n        // previous v\n        const v = fY(y / cellSize) - (btt ? 0 : 1);\n        strips[v]?.push([[x, y], [xX, xY]]);\n        // update current position\n        x = xX;\n        y = xY;\n    }\n}\n\nvar a = [[1, 1], [1, 1]];\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/clip-line-segment-to-strips.ts?\n}')},"./src/utils/create-empty-grid.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyGrid: () => (/* binding */ createEmptyGrid)\n/* harmony export */ });\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../row-count.js */ "./src/row-count.ts");\n\n/**\n *\n * @param colCount\n * @param padCount\n */\nfunction createEmptyGrid(colCount, padCount) {\n    const grid = [];\n    // for (let u=0; u<ROW_COUNT + 2*padCount; u++) {\n    for (let u = 0; u < colCount + 2 * padCount; u++) {\n        const cells = [];\n        for (let v = 0; v < _row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + 2 * padCount; v++) {\n            cells.push({\n                lineSegs: [],\n                closeCells: [],\n                crossingCells: []\n            });\n        }\n        grid.push(cells);\n    }\n    return grid;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/create-empty-grid.ts?\n}')},"./src/utils/find-close-cells.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findCloseCells: () => (/* binding */ findCloseCells)\n/* harmony export */ });\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../row-count.js */ "./src/row-count.ts");\n/* harmony import */ var _calc_circs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calc-circs.js */ "./src/utils/calc-circs.ts");\n/* harmony import */ var _jump_idx_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jump-idx.js */ "./src/utils/jump-idx.ts");\n\n\n\nconst { min, max, SQRT2 } = Math;\nfunction findCloseCells(grid, colCount, cellSize, maxDistance, padCount) {\n    const findCloseCellsFor_ = findCloseCellsFor(grid, colCount, cellSize, maxDistance, padCount);\n    let _minD = 0; // minimum for previous row, col 0\n    let minD = 0;\n    for (let i = padCount; i < colCount + padCount; i++) {\n        minD = _minD;\n        for (let j = padCount; j < _row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + padCount; j++) {\n            minD = findCloseCellsFor_(i, j, minD);\n            if (j === padCount) {\n                _minD = minD;\n            }\n        }\n    }\n}\nfunction findCloseCellsFor(grid, colCount, cellSize, maxDistance, padCount) {\n    return function findCloseCellsFor_(i, j, _minD) {\n        // reduce current circle search range since we moved one square\n        let k = (0,_jump_idx_js__WEBPACK_IMPORTED_MODULE_2__.jumpIdx)((_minD - SQRT2 * cellSize) / cellSize);\n        let minD = Number.POSITIVE_INFINITY;\n        while (true) {\n            if (k >= _calc_circs_js__WEBPACK_IMPORTED_MODULE_1__.circsCache.length) {\n                minD = cellSize * (_calc_circs_js__WEBPACK_IMPORTED_MODULE_1__.circsCache[_calc_circs_js__WEBPACK_IMPORTED_MODULE_1__.circsCache.length - 1].from - SQRT2);\n                break;\n            }\n            const { u, v, from } = _calc_circs_js__WEBPACK_IMPORTED_MODULE_1__.circsCache[k];\n            // `SQRT2` to account for diagonal\n            if (cellSize * from > maxDistance + SQRT2 * cellSize) {\n                minD = cellSize * (from - 2 * SQRT2);\n                break;\n            }\n            const u_ = u + i;\n            const v_ = v + j;\n            if (u_ < 0 || u_ >= colCount + 2 * padCount ||\n                v_ < 0 || v_ >= _row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + 2 * padCount) {\n                k++;\n                continue;\n            }\n            const { lineSegs } = grid[u_][v_];\n            if (lineSegs.length > 0) {\n                minD = cellSize * (from - SQRT2);\n                break;\n            }\n            k++;\n        }\n        const { closeCells } = grid[i][j];\n        let l = max(0, k - 1);\n        while (l < _calc_circs_js__WEBPACK_IMPORTED_MODULE_1__.circsCache.length) {\n            const { from, u, v } = _calc_circs_js__WEBPACK_IMPORTED_MODULE_1__.circsCache[l];\n            // `SQRT2` to account for diagonal (times 2 since we minused it off earlier)\n            if (cellSize * from > min(minD, maxDistance) + 2 * SQRT2 * cellSize) {\n                break;\n            }\n            const u_ = u + i;\n            const v_ = v + j;\n            if (u_ < 0 || u_ >= colCount + 2 * padCount ||\n                v_ < 0 || v_ >= _row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + 2 * padCount) {\n                l++;\n                continue;\n            }\n            const { lineSegs } = grid[u_][v_];\n            if (lineSegs.length > 0) {\n                closeCells.push((2 * padCount + _row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT) * u_ + v_);\n            }\n            l++;\n        }\n        return minD;\n    };\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/find-close-cells.ts?\n}')},"./src/utils/find-crossing-cells.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findCrossingCells: () => (/* binding */ findCrossingCells)\n/* harmony export */ });\n/* harmony import */ var _row_count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../row-count.js */ "./src/row-count.ts");\n\nfunction findCrossingCells(grid, colCount, padCount) {\n    for (let i = padCount; i < colCount + padCount; i++) {\n        for (let j = padCount; j < _row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + padCount; j++) {\n            const cc = grid[i][j].crossingCells;\n            for (let k = padCount; k <= i; k++) {\n                if (grid[k][j].lineSegs.length === 0) {\n                    continue;\n                }\n                cc.push((_row_count_js__WEBPACK_IMPORTED_MODULE_0__.ROW_COUNT + 2 * padCount) * k + j);\n            }\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/find-crossing-cells.ts?\n}')},"./src/utils/get-distance-to-line-function.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDistanceToLineFunction: () => (/* binding */ getDistanceToLineFunction)\n/* harmony export */ });\nconst { sqrt } = Math;\n/**\n * Returns a function that returns the signed distance to the given line from\n * the given point.\n *\n * @param pS a point on the line\n * @param pE a different point on the line; if `pS` is the same as `pE` then\n * the distance to the point `pS` (or `pE`) will be returned.\n */\nfunction getDistanceToLineFunction(pS, pE) {\n    const xS = pS[0];\n    const yS = pS[1];\n    const xE = pE[0];\n    const yE = pE[1];\n    const s = yS - yE;\n    const t = xE - xS;\n    const v = xS * yE - xE * yS;\n    // Calculate the length of the line for normalization\n    const lineLength = sqrt(s * s + t * t);\n    return function (p) {\n        const x = p[0];\n        const y = p[1];\n        // Calculate the perpendicular distance from point to line\n        return lineLength !== 0\n            ? (s * x + t * y + v) / lineLength\n            : sqrt((x - xS) ** 2 + (y - yS) ** 2);\n    };\n}\n\n// Quokka tests\n{\n    const pS = [6, 2];\n    const pE = [6, 2];\n    const p = [10, 1];\n    const f = getDistanceToLineFunction(pS, pE);\n    f(p); //?\n}\n// {\n//     const p0 = [0,0];\n//     const p1 = [6,1];\n//     const p2 = [10,1];\n//     const f = getDistanceToLineFunction(p0,p2);\n//     f(p1);//?\n// }\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/get-distance-to-line-function.ts?\n}")},"./src/utils/jump-idx.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jumpIdx: () => (/* binding */ jumpIdx)\n/* harmony export */ });\n/* harmony import */ var _calc_circs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calc-circs.js */ "./src/utils/calc-circs.ts");\n\nconst { max, E } = Math;\n/**\n * @param v\n */\nfunction binarySearchRange(v) {\n    let min = 0;\n    let max = _calc_circs_js__WEBPACK_IMPORTED_MODULE_0__.circsCache.length - 1;\n    let mid = 0;\n    while (min <= max) {\n        mid = (min + max) >>> 1;\n        const midVal = _calc_circs_js__WEBPACK_IMPORTED_MODULE_0__.circsCache[mid].from;\n        if (midVal === v) {\n            return mid;\n        }\n        else if (v > midVal) {\n            min = mid + 1;\n        }\n        else {\n            max = mid - 1;\n        }\n    }\n    return mid;\n}\nfunction jumpIdx(c) {\n    let idx = binarySearchRange(c);\n    c = max(0, c);\n    if (idx === 0) {\n        return 0;\n    }\n    while (_calc_circs_js__WEBPACK_IMPORTED_MODULE_0__.circsCache[idx].from === _calc_circs_js__WEBPACK_IMPORTED_MODULE_0__.circsCache[idx - 1].from) {\n        idx--;\n    }\n    return idx;\n}\n// const [Q,R] = [10.606601717798213, 35.531676008879735];\n// const [A1,B1,F1] = [102.42126, 0.153169, -117.56077];\n// const [A2,B2,C2,D2,F2] = [-0.000660087, 0.388148, 841.25744, -0.0529616, -1089.49916];\n// const [A3,B3,C3,D3,F3] = [-7567711.63, -0.0251756, 7562560.69, 0.025054, -7475.16953];\n// function jumpIdxOld(\n//         c: number) {\n//     let idx = trunc(\n//         c <= 0 ? 0 : c <= 0.7071067811865476 ? 1 : c <= 1.5 ? 5\n//         // Three-part regression (faster than binary search in this case)\n//         : (c <= Q) \n//         ? A1*(E**(B1*c)) + F1\n//         : c <= R\n//         ? A2*(E**(B2*c)) + C2*(E**(-D2*c)) + F2\n//         : A3*(E**(B3*c)) + C3*(E**(-D3*c)) + F3);\n//     c = max(0, c);\n//     while (circsCache[idx].from > c) { idx--; }\n//     while (circsCache[idx + 1].from < c) { idx++; }\n//     return idx;\n// }\n\n// Quokka tests\n// circsCache.slice(0,10);//?\n// circsCache.slice(0,30).map(c => c.from);//?\n// circsCache[5].from;//?\n// circsCache[12].from;//?\n// circsCache[15].from;//?\n// // circsCache.length;//?\n// jumpIdxOld(1.5811388300841898);//?\n// const v = (53.08771209782213 - Math.SQRT2*24.09375)/24.09375;//?\n// jumpIdx(v);//?\n// circsCache[8].from;//?\n// binarySearchRange(1.5811388300841898);//?\n// jumpIdxOld(3.7);//?\n// jumpIdx(3.7);//?\n// // binarySearchRange(3.7);//?\n// jumpIdxOld(0);//?\n// jumpIdx(0);//?\n// // binarySearchRange(0);//?\n// jumpIdxOld(13.7);//?\n// jumpIdx(13.7);//?\n// // binarySearchRange(13.7);//?\n// jumpIdxOld(33.7);//?\n// jumpIdx(33.7);//?\n// // binarySearchRange(33.7);//?\n// // jumpIdxOld(55);//?\n// // jumpIdx(55);//?\n// binarySearchRange(55);//?\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/jump-idx.ts?\n}')},"./src/utils/map-to-viewbox.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapToViewbox: () => (/* binding */ mapToViewbox)\n/* harmony export */ });\nfunction mapToViewbox(viewbox, width, height, psss) {\n    if (viewbox[0] === 0 && viewbox[1] === 0 &&\n        viewbox[2] === width && viewbox[3] === height) {\n        return psss;\n    }\n    const [vx, vy, vw, vh] = viewbox;\n    const scaleX = width / vw;\n    const scaleY = height / vh;\n    const psss_ = [];\n    for (let i = 0; i < psss.length; i++) {\n        const pss = psss[i];\n        const pss_ = [];\n        for (let j = 0; j < pss.length; j++) {\n            const ps = pss[j];\n            const ps_ = [];\n            for (let k = 0; k < ps.length; k++) {\n                const [x, y] = ps[k];\n                const x_ = scaleX * x - vx;\n                const y_ = scaleY * y - vy;\n                ps_.push([x_, y_]);\n            }\n            pss_.push(ps_);\n        }\n        psss_.push(pss_);\n    }\n    return psss_;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/map-to-viewbox.ts?\n}")},"./src/utils/seg-box-x.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   segBoxX: () => (/* binding */ segBoxX)\n/* harmony export */ });\n/**\n * Returns the ordered (by t-value) intersection points of the given line\n * segment and square.\n *\n * @param seg a line segment given by its endpoints\n * @param square a square given by its two opposing corner points, min-x, min-y\n * first\n */\nfunction segBoxX(seg, square) {\n    const [p0, p1] = seg;\n    const [x0, y0] = p0;\n    const [x1, y1] = p1;\n    const [[minX, minY], [maxX, maxY]] = square;\n    // Check if line segment intersects any of the four square edges\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    // Parametric line equation: P(t) = P1 + t*(P2-P1), where 0 <= t <= 1\n    const ts = [];\n    const ps = [];\n    if (dx !== 0) {\n        // Check intersection with left edge (x = minX)\n        const tL = (minX - x0) / dx;\n        if (tL >= 0 && tL <= 1) {\n            const y = y0 + tL * dy;\n            if (y >= minY && y <= maxY) {\n                ts.push(tL);\n                ps.push([minX, y]);\n            }\n        }\n        // Check intersection with right edge (x = maxX)\n        const tR = (maxX - x0) / dx;\n        if (tR >= 0 && tR <= 1) {\n            const y = y0 + tR * dy;\n            if (y >= minY && y <= maxY) {\n                ts.push(tR);\n                ps.push([maxX, y]);\n            }\n        }\n    }\n    if (dy !== 0) {\n        // Check intersection with bottom edge (y = minY)\n        const tT = (minY - y0) / dy;\n        if (tT >= 0 && tT <= 1) {\n            const x = x0 + tT * dx;\n            if (x >= minX && x <= maxX) {\n                ts.push(tT);\n                ps.push([x, minY]);\n            }\n        }\n        // Check intersection with top edge (y = maxY)\n        const tB = (maxY - y0) / dy;\n        if (tB >= 0 && tB <= 1) {\n            const x = x0 + tB * dx;\n            if (x >= minX && x <= maxX) {\n                ts.push(tB);\n                ps.push([x, maxY]);\n            }\n        }\n    }\n    // TODO might be more than 2!!\n    if (ts.length === 2) {\n        return ts[0] < ts[1]\n            ? ps\n            : [ps[1], ps[0]];\n    }\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/seg-box-x.ts?\n}")},"./src/utils/seg-strip-x.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   segStripX: () => (/* binding */ segStripX)\n/* harmony export */ });\n/**\n * Returns the ordered (by t-value) intersection points of the given line\n * segment and half-open strip.\n *\n * @param seg a line segment given by its endpoints\n * @param strip a half-open strip given by max-x, min-y, max-y\n */\nfunction segStripX(seg, strip) {\n    const [p0, p1] = seg;\n    const [x0, y0] = p0;\n    const [x1, y1] = p1;\n    const [maxX, minY, maxY] = strip;\n    // Check if line segment intersects any of the four square edges\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    // Parametric line equation: P(t) = P1 + t*(P2-P1), where 0 <= t <= 1\n    const ts = [];\n    const ps = [];\n    if (dx !== 0) {\n        // Check intersection with right edge (x = maxX)\n        const tL = (maxX - x0) / dx;\n        if (tL >= 0 && tL <= 1) {\n            const y = y0 + tL * dy;\n            if (y >= minY && y <= maxY) {\n                ts.push(tL);\n                ps.push([maxX, y]);\n            }\n        }\n    }\n    if (dy !== 0) {\n        // Check intersection with bottom edge (y = minY)\n        const tT = (minY - y0) / dy;\n        if (tT >= 0 && tT <= 1) {\n            const x = x0 + tT * dx;\n            if (x <= maxX) {\n                ts.push(tT);\n                ps.push([x, minY]);\n            }\n        }\n        // Check intersection with top edge (y = maxY)\n        const tB = (maxY - y0) / dy;\n        if (tB >= 0 && tB <= 1) {\n            const x = x0 + tB * dx;\n            if (x <= maxX) {\n                ts.push(tB);\n                ps.push([x, maxY]);\n            }\n        }\n    }\n    if (ts.length === 2) {\n        return ts[0] < ts[1]\n            ? ps\n            : [ps[1], ps[0]];\n    }\n    return ps;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/utils/seg-strip-x.ts?\n}")},"./src/vector/dot.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dot: () => (/* binding */ dot)\n/* harmony export */ });\n/**\n * Returns the dot (inner) product between two 2-vectors.\n *\n * @param a the first vector\n * @param b the second vector\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/vector/dot.ts?\n}")},"./src/vector/from-to-vec.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromToVec: () => (/* binding */ fromToVec)\n/* harmony export */ });\n/**\n * Returns the second 2-vector minus the first.\n *\n * @param p the first vector\n * @param q the second vector\n  */\nfunction fromToVec(p, q) {\n    return [q[0] - p[0], q[1] - p[1]];\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/vector/from-to-vec.ts?\n}")},"./src/vector/len.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   len: () => (/* binding */ len)\n/* harmony export */ });\n/**\n * Returns the length of the given 2-vector.\n * @param p a 2d vector\n */\nfunction len(p) {\n    return Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/vector/len.ts?\n}")},"./src/webgl-utils/compile-shader.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileShader: () => (/* binding */ compileShader)\n/* harmony export */ });\nfunction compileShader(gl, src, type) {\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n    return shader;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/compile-shader.ts?\n}")},"./src/webgl-utils/free-gl-context.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   freeGlContext: () => (/* binding */ freeGlContext)\n/* harmony export */ });\nfunction freeGlContext(glContext) {\n    if (glContext === undefined) {\n        return;\n    }\n    const { gl, programs, textures } = glContext;\n    for (let key in programs) {\n        const { attributes, fragmentShader, vertexShader, uniformBlocks, program } = programs[key];\n        for (let key in uniformBlocks) {\n            const { buf } = uniformBlocks[key];\n            gl.deleteBuffer(buf);\n        }\n        for (let key in attributes) {\n            const { buf } = attributes[key];\n            gl.deleteBuffer(buf);\n        }\n        gl.deleteShader(fragmentShader);\n        gl.deleteShader(vertexShader);\n        gl.deleteProgram(program);\n    }\n    for (let key in textures) {\n        const { tex } = textures[key];\n        gl.deleteTexture(tex);\n    }\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/free-gl-context.ts?\n}")},"./src/webgl-utils/get-gl-context.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWebGlContext: () => (/* binding */ getWebGlContext)\n/* harmony export */ });\nconst cache = new WeakMap();\n/**\n * Returns a `GlContext` by reference via a cache of `WebGL2RenderingContext`s.\n * * if `gl` doesn't exist in the cache yet a new context is created.\n *\n * @param gl the `WebGL2RenderingContext` context to wrap\n * @param callback\n */\nfunction getWebGlContext(gl) {\n    {\n        const glContext = cache.get(gl);\n        if (glContext) {\n            return glContext;\n        }\n    }\n    const programs = {};\n    const textures = {};\n    gl.canvas.addEventListener('webglcontextlost', e => {\n        onContextLoss();\n        e.preventDefault();\n    }, false);\n    const glContext = {\n        gl,\n        onContextLoss,\n        textures,\n        programs\n    };\n    cache.set(gl, glContext);\n    return glContext;\n    ////////////////////////\n    function onContextLoss() {\n        deleteAllProps(programs);\n        deleteAllProps(textures);\n    }\n}\nfunction deleteAllProps(o) {\n    Object.keys(o).forEach(key => { delete o[key]; });\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/get-gl-context.ts?\n}")},"./src/webgl-utils/set-attribute.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setAttribute: () => (/* binding */ setAttribute)\n/* harmony export */ });\nconst { \n// Integer types\nBYTE, // 5120\nUNSIGNED_BYTE, // 5121\nSHORT, // 5122\nUNSIGNED_SHORT, // 5123\nINT, // 5124\nUNSIGNED_INT, // 5125\n// Float types\nFLOAT, // 5126\nHALF_FLOAT, // 5131\nINT_2_10_10_10_REV, // 36255\nUNSIGNED_INT_2_10_10_10_REV // 33640\n } = WebGL2RenderingContext;\n/**\n *\n * @param name name used in glsl shaders\n * @param size the number of components per vertex attribute. Must be 1, 2, 3, or 4.\n * @param usage one of `gl.STATIC_DRAW`, `gl.DYNAMIC_DRAW`, `gl.STREAM_DRAW`, etc.\n * @param data\n * @param instancingDivisor defaults to 0; 0, 1, ...\n * @param stride defaults to 0;\n * @param offset defaults to 0;\n */\nfunction setAttribute(program) {\n    return (name, size, type, usage, data, instancingDivisor = 0, stride = 0, offset = 0) => {\n        const { gl, attributes } = program;\n        const attr = attributes[name] = attributes[name] ?? {\n            buf: gl.createBuffer(),\n            loc: gl.getAttribLocation(program.program, name),\n            data: null\n        };\n        const { loc, buf } = attr;\n        gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n        if (type === FLOAT || type === HALF_FLOAT) {\n            gl.vertexAttribPointer(loc, size, type, false, stride, offset);\n        }\n        else {\n            gl.vertexAttribIPointer(loc, size, type, stride, offset);\n        }\n        gl.enableVertexAttribArray(loc);\n        if (instancingDivisor !== 0) {\n            gl.vertexAttribDivisor(loc, instancingDivisor);\n        }\n        if (data !== attr.data) {\n            gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n            attr.data = data;\n        }\n    };\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/set-attribute.ts?\n}")},"./src/webgl-utils/set-uniform-block.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setUniformBlock: () => (/* binding */ setUniformBlock)\n/* harmony export */ });\n/**\n *\n * @param program_\n * @param blockName used both as reference within the `Program` and within\n * the GLSL shaders\n */\nfunction setUniformBlock(program_) {\n    return (blockName, bindingPoint, buffer) => {\n        const { gl, uniformBlocks, program } = program_;\n        // const sizeInBytes = buffer.byteLength;\n        let uniformBlock = uniformBlocks[blockName];\n        if (uniformBlocks[blockName] === undefined) {\n            const blockIndex = gl.getUniformBlockIndex(program, blockName);\n            gl.uniformBlockBinding(program, blockIndex, bindingPoint);\n            const buf = gl.createBuffer();\n            gl.bindBuffer(gl.UNIFORM_BUFFER, buf);\n            uniformBlock = { blockName, blockIndex, buf };\n            uniformBlocks[blockName] = uniformBlock;\n        }\n        else {\n            gl.bindBuffer(gl.UNIFORM_BUFFER, uniformBlock.buf);\n        }\n        const { buf } = uniformBlock;\n        gl.bufferData(gl.UNIFORM_BUFFER, buffer, gl.STATIC_DRAW);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPoint, buf);\n    };\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/set-uniform-block.ts?\n}")},"./src/webgl-utils/set-uniform.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setUniform: () => (/* binding */ setUniform)\n/* harmony export */ });\nfunction setUniform(program) {\n    return (type, name, ...values) => {\n        const { gl, uniforms } = program;\n        const uniformLoc = uniforms[name] ||\n            (uniforms[name] = gl.getUniformLocation(program.program, name));\n        // @ts-ignore\n        gl[`uniform${type}`](uniformLoc, ...values);\n    };\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/set-uniform.ts?\n}")},"./src/webgl-utils/use-program.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initProgram: () => (/* binding */ initProgram)\n/* harmony export */ });\n/* harmony import */ var _compile_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compile-shader.js */ "./src/webgl-utils/compile-shader.ts");\n\n/**\n * Initiates a WebGL2 program by:\n *\n * * keeping track of `attributes` and `uniforms` locally (within the returned `Program`)\n * * GL: `createProgram`\n * * GL: `compileShader` and `attachShader` (for both Vertex and Fragment shaders)\n * * GL: `linkProgram`\n *\n * @param glContext a context encapsulating our WebGl2 context\n * @param name a name for us to refer to this program\n * @param vert the vertex shader for this program\n * @param frag the fragment shader for this program\n */\nfunction initProgram(glContext, name, vert, frag) {\n    const { gl, programs } = glContext;\n    if (programs[name]) {\n        return programs[name];\n    }\n    const attributes = {};\n    const uniforms = {};\n    const uniformBlocks = {};\n    const program = gl.createProgram();\n    const vertexShader = (0,_compile_shader_js__WEBPACK_IMPORTED_MODULE_0__.compileShader)(gl, vert, gl.VERTEX_SHADER);\n    const fragmentShader = (0,_compile_shader_js__WEBPACK_IMPORTED_MODULE_0__.compileShader)(gl, frag, gl.FRAGMENT_SHADER);\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    programs[name] = {\n        gl,\n        program,\n        attributes,\n        uniforms,\n        uniformBlocks,\n        vertexShader,\n        fragmentShader\n    };\n    return programs[name];\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/use-program.ts?\n}')},"./src/webgl-utils/use-texture.ts"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTexture: () => (/* binding */ useTexture)\n/* harmony export */ });\n/**\n *\n * @param glContext\n * @param textureIndex the texture index to use on the GPU\n * @param name a custom name to give to the texture for caching\n */\nfunction useTexture(glContext, textureIndex, name) {\n    const { gl, textures } = glContext;\n    gl.activeTexture(gl.TEXTURE0 + textureIndex);\n    let texture = textures[name];\n    if (!texture) {\n        texture = textures[name] = { tex: gl.createTexture() };\n        gl.bindTexture(gl.TEXTURE_2D, texture.tex);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    else {\n        gl.bindTexture(gl.TEXTURE_2D, texture.tex);\n    }\n    return texture;\n}\n\n\n\n//# sourceURL=webpack://webgl2-sdf/./src/webgl-utils/use-texture.ts?\n}")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;if(void 0===__webpack_modules__[e]){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.ts");const __webpack_exports__freeGlContext=__webpack_exports__.freeGlContext,__webpack_exports__generateIntoFramebuffer=__webpack_exports__.generateIntoFramebuffer,__webpack_exports__getWebGlContext=__webpack_exports__.getWebGlContext;export{__webpack_exports__freeGlContext as freeGlContext,__webpack_exports__generateIntoFramebuffer as generateIntoFramebuffer,__webpack_exports__getWebGlContext as getWebGlContext};