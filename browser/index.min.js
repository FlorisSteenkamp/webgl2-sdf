const n=new WeakMap;function e(n){Object.keys(n).forEach(e=>{delete n[e]})}const t=32,r={};function o(n,e,t){const r=n.createShader(t);return n.shaderSource(r,e),n.compileShader(r),r}function s(n,e,t){const{gl:r,textures:o}=n;r.activeTexture(r.TEXTURE0+e);let s=o[t];return s?r.bindTexture(r.TEXTURE_2D,s.tex):(s=o[t]={tex:r.createTexture()},r.bindTexture(r.TEXTURE_2D,s.tex),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),s}const{BYTE:i,UNSIGNED_BYTE:c,SHORT:l,UNSIGNED_SHORT:u,INT:a,UNSIGNED_INT:d,FLOAT:f,HALF_FLOAT:g,INT_2_10_10_10_REV:h,UNSIGNED_INT_2_10_10_10_REV:I}=WebGL2RenderingContext;function x(n){return(e,t,r)=>{const{gl:o,uniformBlocks:s,program:i}=n;let c=s[e];if(void 0===s[e]){const n=o.getUniformBlockIndex(i,e);o.uniformBlockBinding(i,n,t);const r=o.createBuffer();o.bindBuffer(o.UNIFORM_BUFFER,r),c={blockName:e,blockIndex:n,buf:r},s[e]=c}else o.bindBuffer(o.UNIFORM_BUFFER,c.buf);const{buf:l}=c;o.bufferData(o.UNIFORM_BUFFER,r,o.DYNAMIC_DRAW),o.bindBufferBase(o.UNIFORM_BUFFER,t,l)}}function _(n){const e=n[0][0],t=n[0][1];for(let r=1;r<n.length;r++)if(e!==n[r][0]||t!==n[r][1])return!1;return!0}function p(n,e){if(0===e)return n[0];if(1===e)return n[n.length-1];if(4===n.length){const[[t,r],[o,s],[i,c],[l,u]]=n,a=t+(o-t)*e,d=o+(i-o)*e,f=a+(d-a)*e,g=r+(s-r)*e,h=s+(c-s)*e,I=g+(h-g)*e;return[f+(d+(i+(l-i)*e-d)*e-f)*e,I+(h+(c+(u-c)*e-h)*e-I)*e]}if(3===n.length){const[[t,r],[o,s],[i,c]]=n,l=t+(o-t)*e,u=r+(s-r)*e;return[l+(o+(i-o)*e-l)*e,u+(s+(c-s)*e-u)*e]}if(2===n.length){const[[t,r],[o,s]]=n;return[t+(o-t)*e,r+(s-r)*e]}if(1===n.length)return n[0];throw new Error("The given bezier curve must be of order <= 3.")}const{sqrt:v}=Math;function m(n,e){const t=n[0],r=n[1],o=e[0],s=e[1],i=r-s,c=o-t,l=t*s-o*r,u=v(i*i+c*c);return function(n){const e=n[0],o=n[1];return 0!==u?(i*e+c*o+l)/u:v((e-t)**2+(o-r)**2)}}{const n=[10,1];m([6,2],[6,2])(n)}function C(n,e,t){if(4===n.length)return function(n,e,t){return 0===e?1===t?n:function(n,e){const t=n[0],r=n[1],o=n[2],s=n[3],i=t[0],c=t[1],l=r[0],u=r[1],a=o[0],d=o[1],f=i-e*(i-l),g=l-e*(l-a),h=f-e*(f-g),I=c-e*(c-u),x=u-e*(u-d),_=I-e*(I-x);return[t,[f,I],[h,_],[h-e*(h-(g-e*(g-(a-e*(a-s[0]))))),_-e*(_-(x-e*(x-(d-e*(d-s[1])))))]]}(n,t):1===t?function(n,e){const t=n[0],r=n[1],o=n[2],s=n[3],i=t[0],c=t[1],l=r[0],u=r[1],a=o[0],d=o[1],f=i-e*(i-l),g=l-e*(l-a),h=a-e*(a-s[0]),I=f-e*(f-g),x=g-e*(g-h),_=c-e*(c-u),p=u-e*(u-d),v=d-e*(d-s[1]),m=_-e*(_-p),C=p-e*(p-v);return[[I-e*(I-x),m-e*(m-C)],[x,C],[h,v],s]}(n,e):function(n,e,t){const r=n[0],o=n[1],s=n[2],i=n[3],c=r[0],l=r[1],u=o[0],a=o[1],d=s[0],f=s[1],g=e*e,h=e*g,I=t*t,x=t*I,_=e*t,p=c-u,v=d-u,m=p+v,C=e*p,S=t*p,R=i[0]-c-3*v,E=l-a,T=f-a,b=E+T,w=e*E,P=t*E,A=i[1]-l-3*T;return[[h*R+(3*e*(e*m-p)+c),h*A+(3*e*(e*b-E)+l)],[_*(e*R+2*m)+(g*m+c-(S+2*C)),_*(e*A+2*b)+(g*b+l-(P+2*w))],[_*(t*R+2*m)+(I*m+c-(2*S+C)),_*(t*A+2*b)+(I*b+l-(2*P+w))],[x*R+(3*t*(t*m-p)+c),x*A+(3*t*(t*b-E)+l)]]}(n,e,t)}(n,e,t);if(3===n.length)return function(n,e,t){return 0===e?1===t?n:function(n,e){const t=n[0],r=n[1],o=n[2],s=t[0],i=t[1],c=r[0],l=r[1],u=e*e,a=s-c,d=i-l;return[t,[-e*a+s,-e*d+i],[u*(a+(o[0]-c))-(2*e*a-s),u*(d+(o[1]-l))-(2*e*d-i)]]}(n,t):1===t?function(n,e){const t=n[0],r=n[1],o=n[2],s=t[0],i=t[1],c=r[0],l=r[1],u=e*e,a=s-c,d=o[0]-c,f=i-l,g=o[1]-l;return[[u*(a+d)-(2*e*a-s),u*(f+g)-(2*e*f-i)],[e*d+c,e*g+l],o]}(n,e):function(n,e,t){const r=n[0],o=n[1],s=n[2],i=r[0],c=r[1],l=o[0],u=o[1],a=e*e,d=t*t,f=e*t,g=i-l,h=g+(s[0]-l),I=c-u,x=I+(s[1]-u);return[[a*h-(2*e*g-i),a*x-(2*e*I-c)],[f*h-(g*(t+e)-i),f*x-(I*(t+e)-c)],[d*h-(2*t*g-i),d*x-(2*t*I-c)]]}(n,e,t)}(n,e,t);throw new Error("The given bezier curve must be of order 2 or 3.")}function S(n,e){return[e[0]-n[0],e[1]-n[1]]}function R(n,e){return n[0]*e[0]+n[1]*e[1]}function E(n){const e=S(n[0],n[1]),t=S(n[1],n[3]),r=S(n[3],n[0]),o=S(n[0],n[2]),s=S(n[2],n[3]);return R(r,e)>0||R(t,r)>0||R(r,o)>0||R(s,r)>0}const{abs:T,max:b}=Math;function w(n){const e=m(n[0],n[3]),t=e(n[1]),r=e(n[2]);return(t*r<=0?4/9:3/4)*b(T(t),T(r))}function P(n){const e=S(n[0],n[1]),t=S(n[1],n[2]),r=S(n[2],n[0]);return R(r,e)>0||R(t,r)>0}const{abs:A}=Math;function D(n){if(n[0][0]===n[1][0]&&n[0][1]===n[1][1])return 0;const e=p(n,.5),t=m(n[0],n[2]);return A(t(e))}function y(n,e){const t=3===n.length?function(n,e){const t=[0],r=[1];for(;;){const o=t[t.length-1],s=r[r.length-1],i=C(n,o,s);if(!P(i)&&D(i)<=e){if(t.push(r.pop()),1===s)return t;continue}const c=(o+s)/2;r.push(c)}}(n,e):function(n,e){const t=[0],r=[1];for(;;){const o=t[t.length-1],s=r[r.length-1],i=C(n,o,s);if(!E(i)&&w(i)<=e){if(t.push(r.pop()),1===s)return t;continue}const c=(o+s)/2;r.push(c)}}(n,e),r=[];for(let e=0;e<t.length-1;e++){const o=p(n,t[e]),s=p(n,t[e+1]);r.push([o,s])}return r}function F(n){return Math.sqrt(n[0]*n[0]+n[1]*n[1])}const N=function(){const n=[{from:0,u:0,v:0}];for(let e=0;e<128;e++){n.push({from:e+.5,u:e+1,v:0}),n.push({from:e+.5,u:-e-1,v:0}),n.push({from:e+.5,u:0,v:e+1}),n.push({from:e+.5,u:0,v:-e-1});for(let r=0;r<t;r++){const t=F([.5+e,.5+r]),o=e+1,s=r+1;n.push({from:t,u:o,v:s}),0!==o&&n.push({from:t,u:-o,v:s}),0!==s&&n.push({from:t,u:o,v:-s}),0!==o&&0!==s&&n.push({from:t,u:-o,v:-s})}n.sort((n,e)=>n.from-e.from)}return n}(),{min:U,max:M,sqrt:L}=Math;function k(n,e){const t=n[0],r=n[1],o=t[0],s=t[1],i=r[0],c=r[1],l=e[0],u=e[1],a=o-l,d=s-u,f=i-l-a,g=c-u-d,h=M(0,U(1,-(a*f+d*g)/(f*f+g*g))),I=a+h*f,x=d+h*g;return L(I*I+x*x)}const{trunc:O,max:B,E:X}=Math;function Y(n){let e=function(n){let e=0,t=N.length-1,r=0;for(;e<=t;){r=e+t>>>1;const o=N[r].from;if(o===n)return r;n>o?e=r+1:t=r-1}return r}(n);for(n=B(0,n);0!==e&&N[e].from>=n;)e--;for(;e<N.length-2&&N[e+1].from<n;)e++;return e}const{min:G,SQRT2:j}=Math;const{floor:V,ceil:Q}=Math;function z(n,e,t,r,o,s,i){const c=o*i,[[l,u],[a,d]]=s,f=e+c,g=t+c,h=function(n,e){const[t,r]=n,[o,s]=t,[i,c]=r,[[l,u],[a,d]]=e,f=i-o,g=c-s,h=[],I=[];if(0!==f){const n=(l-o)/f;if(n>=0&&n<=1){const e=s+n*g;e>=u&&e<=d&&(h.push(n),I.push([l,e]))}const e=(a-o)/f;if(e>=0&&e<=1){const n=s+e*g;n>=u&&n<=d&&(h.push(e),I.push([a,n]))}}if(0!==g){const n=(u-s)/g;if(n>=0&&n<=1){const e=o+n*f;e>=l&&e<=a&&(h.push(n),I.push([e,u]))}const e=(d-s)/g;if(e>=0&&e<=1){const n=o+e*f;n>=l&&n<=a&&(h.push(e),I.push([n,d]))}}return 2===h.length?h[0]<h[1]?I:[I[1],I[0]]:I}(s,[[-c,-c],[f,g]]),I=l>-c&&l<f&&u>-c&&u<g,x=a>-c&&a<f&&d>-c&&d<g;if(h.length<2&&!I&&!x)return;const _=a-l,p=d-u,v=a>l?o:-o,m=d>u?o:-o;let C=l,S=u,R=0;const E=v>0,T=m>0,b=E?V:Q,w=T?V:Q;for(;;){let e=o*b((C+v)/o),t=o*w((S+m)/o);const r=(e-l)/_,s=(t-u)/p,x=r<s&&0!==_||0===p,P=x?e:l+s*_,A=x?u+r*p:t;if((r>1||0===_)&&(s>1||0===p)){const e=V(a/o)+i,t=V(d/o)+i;n[e]?.[t]?.lineSegs.push([[C,S],[a,d]]);break}if(P<=-c||A<=-c||P>=f||A>=g){if(!I&&0===R){[C,S]=h[0],R++;continue}{const e=b(C/o)-(E?0:1)+i,t=w(S/o)-(T?0:1)+i,r=[[C,S],h[R]];n[e]?.[t]?.lineSegs.push(r);break}}const D=b(C/o)-(E?0:1)+i,y=w(S/o)-(T?0:1)+i;n[D]?.[y]?.lineSegs.push([[C,S],[P,A]]),C=P,S=A}}const W=256,{floor:H,ceil:q}=Math;function Z(n,e,t){const r=e/n.length,[o,s]=t,i=function(n,e){const[t,r]=n,[o,s]=t,[i,c]=r,[l,u,a]=e,d=i-o,f=c-s,g=[],h=[];if(0!==d){const n=(l-o)/d;if(n>=0&&n<=1){const e=s+n*f;e>=u&&e<=a&&(g.push(n),h.push([l,e]))}}if(0!==f){const n=(u-s)/f;if(n>=0&&n<=1){const e=o+n*d;e<=l&&(g.push(n),h.push([e,u]))}const e=(a-s)/f;if(e>=0&&e<=1){const n=o+e*d;n<=l&&(g.push(e),h.push([n,a]))}}return 2===g.length?g[0]<g[1]?h:[h[1],h[0]]:h}(t,[0,0,e]),[c,l]=o,[u,a]=s,d=u-c,f=a-l,g=c<0&&l>0&&l<e,h=u<0&&a>0&&a<e;if(i.length<2&&!g&&!h&&(0!==c||0!==d||l<=0&&a<=0||l>=e&&a>=e))return;if(0===f)return;const I=a>l?r:-r;let x=c,_=l,p=0;const v=u>c,m=a>l,C=m?H:q;for(;;){let t=v&&x<0||!v&&x>0?0:Number.NEGATIVE_INFINITY,o=r*C((_+I)/r);const u=(t-c)/d,a=(o-l)/f,h=u<a&&0!==d,S=h?0:c+a*d,R=h?l+u*f:o;if((u>1||0===d)&&a>1){const e=H(s[1]/r);n[e]?.lineSegs.push([[x,_],s]);break}if(S>=0&&(0!==c||0!==d)||R<=0||R>=e){if(!g&&0===p){[x,_]=i[0],p++;continue}{const e=C(_/r)-(m?0:1),t=[[x,_],i[p]];n[e]?.lineSegs.push(t);break}}const E=C(_/r)-(m?0:1);n[E]?.lineSegs.push([[x,_],[S,R]]),x=S,_=R}}function $(n,e,r,o,s,i,c,l=.5,u=[0,0,e,r],a=1){const d=function(n,e,t,r){if(0===n[0]&&0===n[1]&&n[2]===e&&n[3]===t)return r;const[o,s,i,c]=n,l=e/i,u=t/c,a=[];for(let n=0;n<r.length;n++){const e=r[n],t=[];for(let n=0;n<e.length;n++){const r=e[n],i=[];for(let n=0;n<r.length;n++){const[e,t]=r[n],c=l*e-o,a=u*t-s;i.push([c,a])}t.push(i)}a.push(t)}return a}(u,e,r/a,n),f=function(n,e){let t=[];for(let r=0;r<n.length;r++){const o=n[r];for(let n=0;n<o.length;n++){const r=o[n];if(_(r))continue;if(2===r.length){t.push(r);continue}const s=y(r,e);t.push(...s.filter(n=>!_(n)))}}return t}(d,l),g=function(n,e){const r=[];for(let o=0;o<n+2*e;o++){const n=[];for(let r=0;r<t+2*e;r++)n.push({lineSegs:[],closeCells:[],crossingCells:[]});r.push(n)}return r}(o,c),h=function(){const n=[];for(let e=0;e<t;e++)n.push({lineSegs:[]});return n}();for(let n=0;n<f.length;n++){const t=f[n];z(g,e,r,0,s,t,c),Z(h,r,t)}(function(n,e,r,o,s){const i=function(n,e,r,o,s){return function(i,c,l){let u=Y((l-j*r)/r),a=Number.POSITIVE_INFINITY;for(;u<N.length;){const l=N[u].from;if(r*l>o+j*r)break;const{u:d,v:f}=N[u],g=d+i,h=f+c;if(g<0||g>=e+2*s||h<0||h>=t+2*s){u++;continue}const{lineSegs:I}=n[g][h];for(let n=0;n<I.length;n++){const e=[(i-s+.5)*r,(c-s+.5)*r],t=k(I[n],e);t<a&&(a=t)}if(u++,a!==Number.POSITIVE_INFINITY)break}if(a===Number.POSITIVE_INFINITY)return G(o+j*r,r*N[N.length-1].from);const{closeCells:d}=n[i][c];let f=Y((l-2*j*r)/r);for(;f<N.length;){const{from:l,u,v:g}=N[f];if(r*l>G(a,o)+j*r)break;const h=u+i,I=g+c;if(h<0||h>=e+2*s||I<0||I>=t+2*s){f++;continue}const{lineSegs:x}=n[h][I];x.length>0&&d.push((2*s+t)*h+I),f++}return a}}(n,e,r,o,s);let c=0,l=0;for(let n=s;n<e+s;n++){l=c;for(let e=s;e<t+s;e++)l=i(n,e,l),e===s&&(c=l)}})(g,o,s,i,c),function(n,e,r){for(let o=r;o<e+r;o++)for(let e=r;e<t+r;e++){const s=n[o][e].crossingCells;for(let i=r;i<=o;i++)0!==n[i][e].lineSegs.length&&s.push((t+2*r)*i+e)}}(g,o,c);const I=[],x=[],p=[],v=[],m=[],C=[];let S=0,R=0,E=0;for(let n=0;n<o+2*c;n++)for(let e=0;e<t+2*c;e++){const r=g[n][e];if(n>=c&&n<o+c&&e>=c&&e<t+c){const{closeCells:n,crossingCells:e}=r,t=e.length;m.push(...e),C.push([S,t]),S+=t;const o=n.length;p.push(...n),v.push([R,o]),R+=o}const{lineSegs:s}=r,i=s.length;x.push([E,i]),E+=i,I.push(...s)}for(;p.length%W!==0;)p.push(0);for(;m.length%W!==0;)m.push(0);const T=[];for(let n=0;n<t;n++){const e=h[n],{lineSegs:t}=e,r=t.length;T.push([E,r]),E+=r,I.push(...t)}const b=new Float32Array(I.flat(2)),w=new Int32Array(x.flat()),P=new Int32Array(v.flat());return{lineSegPtCoords_Arr:b,segIdxs_PerCell_Range_Arr:w,closeCellIdxs_PerCell_Arr:new Int32Array(p),closeCellIdxs_PerCell_Range_Arr:P,crossCellIdxs_PerCell_Arr:new Int32Array(m),crossCellIdxs_perCell_Range_Arr:new Int32Array(C.flat()),segIdxs_PerStrip_Range_Arr:new Int32Array(T.flat())}}function J(n){const e=[n.p,n.initialPoint];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e}const K={c:function(n){const e=[n.p,[n.vals[0],n.vals[1]],[n.vals[2],n.vals[3]],[n.vals[4],n.vals[5]]];return n.prev2ndCubicControlPoint=e[2],n.prev2ndQuadraticControlPoint=void 0,e},h:function(n){const e=[n.p,[n.vals[0],n.p[1]]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e},l:function(n){const e=[n.p,n.vals];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e},q:function(n){const e=[n.vals[0],n.vals[1]],t=[n.vals[2],n.vals[3]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=e,[n.p,e,t]},s:function(n){const e=n.prev2ndCubicControlPoint?[n.p[0]-n.prev2ndCubicControlPoint[0]+n.p[0],n.p[1]-n.prev2ndCubicControlPoint[1]+n.p[1]]:n.p,t=[n.p,e,[n.vals[0],n.vals[1]],[n.vals[2],n.vals[3]]];return n.prev2ndCubicControlPoint=t[2],n.prev2ndQuadraticControlPoint=void 0,t},t:function(n){const e=n.prev2ndQuadraticControlPoint?[n.p[0]-n.prev2ndQuadraticControlPoint[0]+n.p[0],n.p[1]-n.prev2ndQuadraticControlPoint[1]+n.p[1]]:n.p,t=[n.vals[0],n.vals[1]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=e,[n.p,e,t]},v:function(n){const e=[n.p,[n.p[0],n.vals[0]]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e},z:J};function nn(n){let e=0,t=0,r=1,o=0,s=1,i=1;const c=n._currentIndex;if(n._skipOptionalSpaces(),n._currentIndex<n._endIndex&&"+"===n._string[n._currentIndex]?n._currentIndex+=1:n._currentIndex<n._endIndex&&"-"===n._string[n._currentIndex]&&(n._currentIndex+=1,s=-1),n._currentIndex===n._endIndex||(n._string[n._currentIndex]<"0"||n._string[n._currentIndex]>"9")&&"."!==n._string[n._currentIndex])throw new Error("The first character of a number must be one of [0-9+-.].");const l=n._currentIndex;for(;n._currentIndex<n._endIndex&&n._string[n._currentIndex]>="0"&&n._string[n._currentIndex]<="9";)n._currentIndex+=1;if(n._currentIndex!==l){let e=n._currentIndex-1,r=1;for(;e>=l;)t+=r*(Number(n._string[e])-0),e-=1,r*=10}if(n._currentIndex<n._endIndex&&"."===n._string[n._currentIndex]){if(n._currentIndex+=1,n._currentIndex>=n._endIndex||n._string[n._currentIndex]<"0"||n._string[n._currentIndex]>"9")throw new Error("There must be a least one digit following the .");for(;n._currentIndex<n._endIndex&&n._string[n._currentIndex]>="0"&&n._string[n._currentIndex]<="9";)r*=10,o+=Number(n._string.charAt(n._currentIndex))/r,n._currentIndex+=1}if(n._currentIndex!==c&&n._currentIndex+1<n._endIndex&&("e"===n._string[n._currentIndex]||"E"===n._string[n._currentIndex])&&"x"!==n._string[n._currentIndex+1]&&"m"!==n._string[n._currentIndex+1]){if(n._currentIndex+=1,"+"===n._string[n._currentIndex]?n._currentIndex+=1:"-"===n._string[n._currentIndex]&&(n._currentIndex+=1,i=-1),n._currentIndex>=n._endIndex||n._string[n._currentIndex]<"0"||n._string[n._currentIndex]>"9")throw new Error("There must be an exponent.");for(;n._currentIndex<n._endIndex&&n._string[n._currentIndex]>="0"&&n._string[n._currentIndex]<="9";)e*=10,e+=Number(n._string[n._currentIndex]),n._currentIndex+=1}let u=t+o;if(u*=s,e&&(u*=Math.pow(10,i*e)),c===n._currentIndex)throw new Error("Internal error: startIndex === source._currentIndex");return n._skipOptionalSpacesOrDelimiter(),u}const en={Z:"Z",M:"M",L:"L",C:"C",Q:"Q",A:"A",H:"H",V:"V",S:"S",T:"T",z:"Z",m:"m",l:"l",c:"c",q:"q",a:"a",h:"h",v:"v",s:"s",t:"t"};class tn{_string;_currentIndex;_endIndex;_prevCommand;constructor(n){this._string=n,this._currentIndex=0,this._endIndex=this._string.length,this._prevCommand=void 0,this._skipOptionalSpaces()}parseSegment(){const n=this._string[this._currentIndex];let e,t=en[n];if(void 0===t){if(void 0===this._prevCommand)throw new Error("Implicit command not allowed for first commands.");if(!("+"===n||"-"===n||"."===n||n>="0"&&n<="9")||"Z"===this._prevCommand)throw new Error("Remaining coordinates not found for implicit command");t="M"===this._prevCommand?"L":"m"===this._prevCommand?"l":this._prevCommand}else this._currentIndex+=1;this._prevCommand=t;const r=t.toUpperCase();if("H"===r||"V"===r?e=[nn(this)]:"M"===r||"L"===r||"T"===r?e=[nn(this),nn(this)]:"S"===r||"Q"===r?e=[nn(this),nn(this),nn(this),nn(this)]:"C"===r?e=[nn(this),nn(this),nn(this),nn(this),nn(this),nn(this)]:"A"===r?e=[nn(this),nn(this),nn(this),this._parseArcFlag(),this._parseArcFlag(),nn(this),nn(this)]:"Z"===r&&(this._skipOptionalSpaces(),e=[]),void 0===e)throw new Error("Unknown command");return{type:t,values:e}}hasMoreData(){return this._currentIndex<this._endIndex}initialCommandIsMoveTo(){if(!this.hasMoreData())return!0;const n=en[this._string[this._currentIndex]];return"M"===n||"m"===n}_isCurrentSpace(){const n=this._string[this._currentIndex];return n<=" "&&(" "===n||"\n"===n||"\t"===n||"\r"===n||"\f"===n)}_skipOptionalSpaces(){for(;this._currentIndex<this._endIndex&&this._isCurrentSpace();)this._currentIndex+=1;return this._currentIndex<this._endIndex}_skipOptionalSpacesOrDelimiter(){return!(this._currentIndex<this._endIndex&&!this._isCurrentSpace()&&","!==this._string[this._currentIndex])&&(this._skipOptionalSpaces()&&this._currentIndex<this._endIndex&&","===this._string[this._currentIndex]&&(this._currentIndex+=1,this._skipOptionalSpaces()),this._currentIndex<this._endIndex)}_parseArcFlag(){if(this._currentIndex>=this._endIndex)throw new Error("Unable to parse arc flag");let n;const e=this._string[this._currentIndex];if(this._currentIndex+=1,"0"===e)n=0;else{if("1"!==e)throw new Error("Unable to parse arc flag - arc flag must be 0 or 1");n=1}return this._skipOptionalSpacesOrDelimiter(),n}}const{ceil:rn,min:on,max:sn}=Math;function cn(i,c,l,u,a,d,h=1,I=!0,_=!0,p=0,v=0,m=0,C=.5){const S="string"==typeof c?function(n){if(0===n.length)return[];if("m"!==n[0].type.toLowerCase())throw new Error("Invalid SVG - every new path must start with an M or m.");const e={p:[0,0]},t=[];let r,o=[];for(let s=0;s<n.length;s++){const i=n[s],c=i.type.toLowerCase();if(e.vals=i.values,i.type===c)if("v"===c)e.vals[0]+=e.p[1];else if("a"===c)e.vals[5]+=e.p[0],e.vals[6]+=e.p[1];else for(let n=0;n<e.vals.length;n++)e.vals[n]+=e.p[n%2];if("m"===c){o.length&&("z"!==r&&o.push(J(e)),t.push(o),o=[]),e.initialPoint=e.p=e.vals,r=c;continue}const l=K[c];if(!l)throw new Error("Invalid SVG - command not recognized.");const u=l(e);e.p=u[u.length-1],o.push(u),r=c}return o.length>0&&("z"!==r&&o.push(J(e)),t.push(o)),t}(function(n){if(!n.length)return[];const e=new tn(n),t=[];if(!e.initialCommandIsMoveTo())throw new Error("Path must start with m or M");for(;e.hasMoreData();)t.push(e.parseSegment());return t}(c)):c,R=function(t){{const e=n.get(t);if(e)return e}const r={},o={},s=[];t.canvas.addEventListener("webglcontextlost",n=>{c(),n.preventDefault()},!1);const i={gl:t,onContextLoss:c,textures:o,programs:r,framebufferStack:s};return n.set(t,i),i;function c(){e(r),e(o),s.length=0}}(i),{onContextLoss:E}=R;let T=1;if(l/u>4){const n=l/4;T=n/u,u=n}const b=u/t,w=sn(l,u),P=rn(l/b),A=2*rn(on(d,w)/b/2),D=function(n,e,t,r){const{gl:s,programs:i}=n;if(i[e])return i[e];const c=s.createProgram();return s.attachShader(c,o(s,"#version 300 es\n\nprecision highp float;\n\nuniform vec2 uWidthHeight;\nuniform float uStretch;\nin vec2 aUV;\nin ivec2 aCloseCellIdxRangePerCell;\nin ivec2 aCrossIdxRangePerCell;\nout vec2 vXY;\nflat out int instanceId;\nflat out ivec2 closeCellIdxRange;\nflat out ivec2 crossCellIdxRange;\n\n\nvoid main() {\n    instanceId = gl_InstanceID;\n    closeCellIdxRange = aCloseCellIdxRangePerCell;\n    crossCellIdxRange = aCrossIdxRangePerCell;\n\n    // drawn column-by-column\n    float i = float(instanceId / 32);  // column index\n    float j = float(instanceId % 32);  // row index\n\n    vec2 trans = vec2(\n        i / float(32),\n        j / float(32)\n    );\n\n    vec2 uv = aUV + trans;\n\n    float width = uWidthHeight.x;\n    float height = uWidthHeight.y;\n\n    vXY = vec2(\n        height * uv.x,\n        height * uv.y\n    );\n\n    float aspectRatio = width / height;\n\n    gl_Position = vec4(\n        vec2(\n            (2.0*(uv.x / aspectRatio) - 1.0),\n            2.0*uv.y - 1.0\n        ),\n        0.0, 1.0\n    );\n}\n",s.VERTEX_SHADER)),s.attachShader(c,o(s,r,s.FRAGMENT_SHADER)),s.linkProgram(c),i[e]={gl:s,program:c,attributes:{},uniforms:{},uniformBlocks:{}},i[e]}(R,`main${P}-${A}`,0,function(n,e){const o=r[1024*n+e];if(void 0!==o)return o;const s=`#version 300 es\n\nprecision highp float;\n\nuniform float uMaxDistance;\nuniform float uExponent;\nuniform highp sampler2D uSegs;\nuniform highp isampler2D uCloseCellIdxs;\nuniform highp isampler2D uCrossCellIdxs;\nuniform int uIncl;  // bit 0 -> incl inside, bit 1 -> incl outside\n\nuniform SegIdxRangePerCellBlock {\n    ivec4 uSegIdxRangePerCell[${(t+2*e)*(n+2*e)/2}];\n};\nuniform SegIdxRangePerStripBlock {\n    ivec4 uSegIdxRangePerStrip[16];\n};\n\nin vec2 vXY;\nflat in int instanceId;\nflat in ivec2 closeCellIdxRange;\nflat in ivec2 crossCellIdxRange;\nout vec4 FragColor;\n\n\nfloat absDistToSegment(vec2 point, vec2 lineA, vec2 lineB) {\n    vec2 lineDir = lineB - lineA;\n    float lenSq = dot(lineDir, lineDir);\n    float t = clamp(dot(point - lineA, lineDir) / lenSq, 0.0, 1.0);\n    vec2 linePt = lineA + t * lineDir;\n\n    return distance(point, linePt);\n}\n\n\nvoid main() {\n    ///////////////////////////////////////////////////////////////////////////\n    // Project a ray to the left to check if it crosses the segment in order\n    // to find the fragment's winding number to determine whether fragment\n    // is inside or outside the shape.\n\n    int crossIdxS = crossCellIdxRange.x;\n    int crossLen = crossCellIdxRange.y;\n    float winds = 0.0;\n    // Iterate over all relevant cell indexes\n    for (int i = crossIdxS; i < crossIdxS + crossLen; i++) {\n        int crossIdx = texelFetch(uCrossCellIdxs, ivec2(i%256, i/256), 0).x;\n\n        bool isEven = crossIdx % 2 == 0;\n\n        ivec4 uSegIdxRange = uSegIdxRangePerCell[crossIdx / 2];\n        int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\n        int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\n\n        for (int j = segIdx; j < segIdx + segLen; j++) {\n            // Fetch segment from texture\n            vec4 seg = texelFetch(uSegs, ivec2(j, 0), 0);\n\n            // line segment's min-y is excluded\n            bool crossing =\n                (seg.y > vXY.y != seg.w > vXY.y) &&\n                (vXY.x > (seg.z - seg.x)*(vXY.y - seg.y) / (seg.w - seg.y) + seg.x);\n\n            bool crossingUp = seg.y < seg.w;\n\n            winds += crossing ? (crossingUp ? 1.0 : -1.0) : 0.0;\n        }\n    }\n\n    {\n        bool isEven = (instanceId % 32) % 2 == 0;\n\n        ivec4 uSegIdxRange = uSegIdxRangePerStrip[(instanceId % 32) / 2];\n        int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\n        int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\n\n        for (int j = segIdx; j < segIdx + segLen; j++) {\n            // Fetch segment from texture\n            vec4 seg = texelFetch(uSegs, ivec2(j, 0), 0);\n\n            // line segment's min-y is excluded\n            bool crossing =\n                (seg.y > vXY.y != seg.w > vXY.y) &&\n                (vXY.x > (seg.z - seg.x)*(vXY.y - seg.y) / (seg.w - seg.y) + seg.x);\n\n            bool crossingUp = seg.y < seg.w;\n\n            winds += crossing ? (crossingUp ? 1.0 : -1.0) : 0.0;\n        }\n    }\n\n\n    bool inside = winds != 0.0;\n    ///////////////////////////////////////////////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////\n    float res = 1.0;  // sdf result\n\n    if ((inside && (uIncl % 2 != 0)) || (!inside && (uIncl > 1))) {\n        int cellIdxS = closeCellIdxRange.x;\n        int cellLen = closeCellIdxRange.y;\n        // Iterate over all relevant cell indexes\n        for (int i = cellIdxS; i < cellIdxS + cellLen; i++) {\n            int cellIdx = texelFetch(uCloseCellIdxs, ivec2(i%256, i/256), 0).x;\n\n            bool isEven = cellIdx % 2 == 0;\n            ivec4 uSegIdxRange = uSegIdxRangePerCell[cellIdx / 2];\n            int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\n            int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\n\n            for (int j = segIdx; j < segIdx + segLen; j++) {\n                // Fetch segment from texture\n                vec4 seg = texelFetch(uSegs, ivec2(j, 0), 0);\n\n                // Find unsigned distance to the segment; only the nearest will be kept\n                float d = absDistToSegment(vXY, seg.xy, seg.zw);\n                // Apply exponential transform TODO\n                // val = pow(1.0 - clamp(d / uMaxDistance, 0.0, 1.0), uExponent) * 0.5;\n                float val = clamp(d / uMaxDistance, 0.0, 1.0);\n                res = min(res, val);\n            }\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////\n\n    // DEBUG!\n    float alpha = ((instanceId + instanceId/32) % 2 == 0 ? 0.3 : 0.5);\n\n    float red = inside ? 0.2 : 0.8;\n    float green = abs(sin(50.0 * res));\n    float blue = 0.5;\n    // float alpha = inside ? 0.5 : 0.0;\n\n    FragColor = vec4(red, green, blue, alpha);\n}\n`;return r[1024*n+e]=s,s}(P,A));if(i.useProgram(D.program),function(n,e,r,o,i,c,l=1,u,a,d,h,I,_,p,v){const{gl:m}=n,C=[],S=.03125,R=.03125;C.push(0,0,S,0,0,R),C.push(S,0,S,R,0,R);const E=new Float32Array(C),T=(b=e,(n,e,...t)=>{const{gl:r,uniforms:o}=b,s=o[e]||(o[e]=r.getUniformLocation(b.program,e));r[`uniform${n}`](s,...t)});var b;const w=function(n){return(e,t,r,o,s,i=0,c=0,l=0)=>{const{gl:u,attributes:a}=n,d=a[e]=a[e]??{buf:u.createBuffer(),loc:u.getAttribLocation(n.program,e),data:null},{loc:h,buf:I}=d;u.bindBuffer(u.ARRAY_BUFFER,I),r===f||r===g?u.vertexAttribPointer(h,t,r,!1,c,l):u.vertexAttribIPointer(h,t,r,c,l),u.enableVertexAttribArray(h),0!==i&&u.vertexAttribDivisor(h,i),s!==d.data&&(u.bufferData(u.ARRAY_BUFFER,s,o),d.data=s)}}(e),{lineSegPtCoords_Arr:P,segIdxs_PerCell_Range_Arr:A,closeCellIdxs_PerCell_Arr:D,closeCellIdxs_PerCell_Range_Arr:y,crossCellIdxs_PerCell_Arr:F,crossCellIdxs_perCell_Range_Arr:N,segIdxs_PerStrip_Range_Arr:U}=$(o,u,a,d,h,c,p,r,i,v);w("aUV",2,m.FLOAT,m.STATIC_DRAW,E),w("aCrossIdxRangePerCell",2,m.INT,m.STATIC_DRAW,N,1),w("aCloseCellIdxRangePerCell",2,m.INT,m.STATIC_DRAW,y,1),T("2f","uWidthHeight",u,a),T("1f","uMaxDistance",c),T("1f","uExponent",l),T("1i","uIncl",(I?1:0)+(_?2:0)),T("1f","uStretch",v),x(e)("SegIdxRangePerCellBlock",0,A),x(e)("SegIdxRangePerStripBlock",1,U),s(n,0,"segs"),m.texImage2D(m.TEXTURE_2D,0,m.RGBA32F,P.length/4,1,0,m.RGBA,m.FLOAT,P);const M=m.getUniformLocation(e.program,"uSegs");m.uniform1i(M,0),s(n,1,"closeCellIdxsPerCell"),m.texImage2D(m.TEXTURE_2D,0,m.R32I,W,D.length/W,0,m.RED_INTEGER,m.INT,D);const L=m.getUniformLocation(e.program,"uCloseCellIdxs");m.uniform1i(L,1),s(n,2,"crossCellIdxsPerCell"),m.texImage2D(m.TEXTURE_2D,0,m.R32I,W,F.length/W,0,m.RED_INTEGER,m.INT,F);const k=m.getUniformLocation(e.program,"uCrossCellIdxs");m.uniform1i(k,2),v>1&&(m.enable(m.SCISSOR_TEST),m.scissor(0,0,u,a/v)),m.viewport(0,0,u,a),m.drawArraysInstanced(m.TRIANGLES,0,6,d*t),v>1&&m.disable(m.SCISSOR_TEST)}(R,D,C,S,a,d,h,l,u,P,b,I,_,A,T),i.isContextLost())throw E(),new Error("Webgl2 context lost.")}export{cn as generateIntoFramebuffer};