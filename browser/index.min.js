const n=32,e={};function t(n,e,t){const r=n.createShader(t);return n.shaderSource(r,e),n.compileShader(r),r}function r(n,e,t){const{gl:r,textures:o}=n;r.activeTexture(r.TEXTURE0+e);let s=o[t];return s?r.bindTexture(r.TEXTURE_2D,s.tex):(s=o[t]={tex:r.createTexture()},r.bindTexture(r.TEXTURE_2D,s.tex),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),s}const{BYTE:o,UNSIGNED_BYTE:s,SHORT:i,UNSIGNED_SHORT:l,INT:c,UNSIGNED_INT:u,FLOAT:a,HALF_FLOAT:d,INT_2_10_10_10_REV:f,UNSIGNED_INT_2_10_10_10_REV:g}=WebGL2RenderingContext;function h(n){return(e,t,r)=>{const{gl:o,uniformBlocks:s,program:i}=n;let l=s[e];if(void 0===s[e]){const n=o.getUniformBlockIndex(i,e);o.uniformBlockBinding(i,n,t);const r=o.createBuffer();o.bindBuffer(o.UNIFORM_BUFFER,r),l={blockName:e,blockIndex:n,buf:r},s[e]=l}else o.bindBuffer(o.UNIFORM_BUFFER,l.buf);const{buf:c}=l;o.bufferData(o.UNIFORM_BUFFER,r,o.STATIC_DRAW),o.bindBufferBase(o.UNIFORM_BUFFER,t,c)}}function x(n){const e=n[0][0],t=n[0][1];for(let r=1;r<n.length;r++)if(e!==n[r][0]||t!==n[r][1])return!1;return!0}function I(n,e){if(0===e)return n[0];if(1===e)return n[n.length-1];if(4===n.length){const[[t,r],[o,s],[i,l],[c,u]]=n,a=t+(o-t)*e,d=o+(i-o)*e,f=a+(d-a)*e,g=r+(s-r)*e,h=s+(l-s)*e,x=g+(h-g)*e;return[f+(d+(i+(c-i)*e-d)*e-f)*e,x+(h+(l+(u-l)*e-h)*e-x)*e]}if(3===n.length){const[[t,r],[o,s],[i,l]]=n,c=t+(o-t)*e,u=r+(s-r)*e;return[c+(o+(i-o)*e-c)*e,u+(s+(l-s)*e-u)*e]}if(2===n.length){const[[t,r],[o,s]]=n;return[t+(o-t)*e,r+(s-r)*e]}if(1===n.length)return n[0];throw new Error("The given bezier curve must be of order <= 3.")}const{sqrt:_}=Math;function p(n,e){const t=n[0],r=n[1],o=e[0],s=e[1],i=r-s,l=o-t,c=t*s-o*r,u=_(i*i+l*l);return function(n){const e=n[0],o=n[1];return 0!==u?(i*e+l*o+c)/u:_((e-t)**2+(o-r)**2)}}{const n=[10,1];p([6,2],[6,2])(n)}function v(n,e,t){if(4===n.length)return function(n,e,t){return 0===e?1===t?n:function(n,e){const t=n[0],r=n[1],o=n[2],s=n[3],i=t[0],l=t[1],c=r[0],u=r[1],a=o[0],d=o[1],f=i-e*(i-c),g=c-e*(c-a),h=f-e*(f-g),x=l-e*(l-u),I=u-e*(u-d),_=x-e*(x-I);return[t,[f,x],[h,_],[h-e*(h-(g-e*(g-(a-e*(a-s[0]))))),_-e*(_-(I-e*(I-(d-e*(d-s[1])))))]]}(n,t):1===t?function(n,e){const t=n[0],r=n[1],o=n[2],s=n[3],i=t[0],l=t[1],c=r[0],u=r[1],a=o[0],d=o[1],f=i-e*(i-c),g=c-e*(c-a),h=a-e*(a-s[0]),x=f-e*(f-g),I=g-e*(g-h),_=l-e*(l-u),p=u-e*(u-d),v=d-e*(d-s[1]),m=_-e*(_-p),C=p-e*(p-v);return[[x-e*(x-I),m-e*(m-C)],[I,C],[h,v],s]}(n,e):function(n,e,t){const r=n[0],o=n[1],s=n[2],i=n[3],l=r[0],c=r[1],u=o[0],a=o[1],d=s[0],f=s[1],g=e*e,h=e*g,x=t*t,I=t*x,_=e*t,p=l-u,v=d-u,m=p+v,C=e*p,S=t*p,R=i[0]-l-3*v,E=c-a,T=f-a,b=E+T,P=e*E,w=t*E,A=i[1]-c-3*T;return[[h*R+(3*e*(e*m-p)+l),h*A+(3*e*(e*b-E)+c)],[_*(e*R+2*m)+(g*m+l-(S+2*C)),_*(e*A+2*b)+(g*b+c-(w+2*P))],[_*(t*R+2*m)+(x*m+l-(2*S+C)),_*(t*A+2*b)+(x*b+c-(2*w+P))],[I*R+(3*t*(t*m-p)+l),I*A+(3*t*(t*b-E)+c)]]}(n,e,t)}(n,e,t);if(3===n.length)return function(n,e,t){return 0===e?1===t?n:function(n,e){const t=n[0],r=n[1],o=n[2],s=t[0],i=t[1],l=r[0],c=r[1],u=e*e,a=s-l,d=i-c;return[t,[-e*a+s,-e*d+i],[u*(a+(o[0]-l))-(2*e*a-s),u*(d+(o[1]-c))-(2*e*d-i)]]}(n,t):1===t?function(n,e){const t=n[0],r=n[1],o=n[2],s=t[0],i=t[1],l=r[0],c=r[1],u=e*e,a=s-l,d=o[0]-l,f=i-c,g=o[1]-c;return[[u*(a+d)-(2*e*a-s),u*(f+g)-(2*e*f-i)],[e*d+l,e*g+c],o]}(n,e):function(n,e,t){const r=n[0],o=n[1],s=n[2],i=r[0],l=r[1],c=o[0],u=o[1],a=e*e,d=t*t,f=e*t,g=i-c,h=g+(s[0]-c),x=l-u,I=x+(s[1]-u);return[[a*h-(2*e*g-i),a*I-(2*e*x-l)],[f*h-(g*(t+e)-i),f*I-(x*(t+e)-l)],[d*h-(2*t*g-i),d*I-(2*t*x-l)]]}(n,e,t)}(n,e,t);throw new Error("The given bezier curve must be of order 2 or 3.")}function m(n,e){return[e[0]-n[0],e[1]-n[1]]}function C(n,e){return n[0]*e[0]+n[1]*e[1]}function S(n){const e=m(n[0],n[1]),t=m(n[1],n[3]),r=m(n[3],n[0]),o=m(n[0],n[2]),s=m(n[2],n[3]);return C(r,e)>0||C(t,r)>0||C(r,o)>0||C(s,r)>0}const{abs:R,max:E}=Math;function T(n){const e=p(n[0],n[3]),t=e(n[1]),r=e(n[2]);return(t*r<=0?4/9:3/4)*E(R(t),R(r))}function b(n){const e=m(n[0],n[1]),t=m(n[1],n[2]),r=m(n[2],n[0]);return C(r,e)>0||C(t,r)>0}const{abs:P}=Math;function w(n){if(n[0][0]===n[1][0]&&n[0][1]===n[1][1])return 0;const e=I(n,.5),t=p(n[0],n[2]);return P(t(e))}function A(n){const e=3===n.length?function(n){const e=[0],t=[1];for(;;){const r=e[e.length-1],o=t[t.length-1],s=v(n,r,o);if(!b(s)&&w(s)<=.5){if(e.push(t.pop()),1===o)return e;continue}const i=(r+o)/2;t.push(i)}}(n):function(n){const e=[0],t=[1];for(;;){const r=e[e.length-1],o=t[t.length-1],s=v(n,r,o);if(!S(s)&&T(s)<=.5){if(e.push(t.pop()),1===o)return e;continue}const i=(r+o)/2;t.push(i)}}(n),t=[];for(let r=0;r<e.length-1;r++){const o=I(n,e[r]),s=I(n,e[r+1]);t.push([o,s])}return t}function D(n){return Math.sqrt(n[0]*n[0]+n[1]*n[1])}const y=function(){const e=[{from:0,u:0,v:0}];for(let t=0;t<128;t++){e.push({from:t+.5,u:t+1,v:0}),e.push({from:t+.5,u:-t-1,v:0}),e.push({from:t+.5,u:0,v:t+1}),e.push({from:t+.5,u:0,v:-t-1});for(let r=0;r<n;r++){const n=D([.5+t,.5+r]),o=t+1,s=r+1;e.push({from:n,u:o,v:s}),0!==o&&e.push({from:n,u:-o,v:s}),0!==s&&e.push({from:n,u:o,v:-s}),0!==o&&0!==s&&e.push({from:n,u:-o,v:-s})}e.sort((n,e)=>n.from-e.from)}return e}(),{max:U,E:F}=Math;const{min:N,max:M,SQRT2:k}=Math;function L(e,t,r,o,s){const i=function(e,t,r,o,s){return function(i,l,c){let u=function(n){let e=function(n){let e=0,t=y.length-1,r=0;for(;e<=t;){r=e+t>>>1;const o=y[r].from;if(o===n)return r;n>o?e=r+1:t=r-1}return r}(n);if(n=U(0,n),0===e)return 0;for(;y[e].from===y[e-1].from;)e--;return e}((c-k*r)/r),a=Number.POSITIVE_INFINITY;for(;;){if(u>=y.length){a=r*(y[y.length-1].from-k);break}const{u:c,v:d,from:f}=y[u];if(r*f>o+k*r){a=r*(f-2*k);break}const g=c+i,h=d+l;if(g<0||g>=t+2*s||h<0||h>=n+2*s){u++;continue}const{lineSegs:x}=e[g][h];if(x.length>0){a=r*(f-k);break}u++}const{closeCells:d}=e[i][l];let f=M(0,u-1);for(;f<y.length;){const{from:c,u,v:g}=y[f];if(r*c>N(a,o)+2*k*r)break;const h=u+i,x=g+l;if(h<0||h>=t+2*s||x<0||x>=n+2*s){f++;continue}const{lineSegs:I}=e[h][x];I.length>0&&d.push((2*s+n)*h+x),f++}return a}}(e,t,r,o,s);let l=0,c=0;for(let e=s;e<t+s;e++){c=l;for(let t=s;t<n+s;t++)c=i(e,t,c),t===s&&(l=c)}}const{floor:B,ceil:O}=Math;function X(n,e,t,r,o,s){const i=r*s,[[l,c],[u,a]]=o,d=e+i,f=t+i,g=function(n,e){const[t,r]=n,[o,s]=t,[i,l]=r,[[c,u],[a,d]]=e,f=i-o,g=l-s,h=[];if(0!==f){const n=(c-o)/f;if(n>=0&&n<=1){const e=s+n*g;e>=u&&e<=d&&h.push({t:n,p:[c,e]})}const e=(a-o)/f;if(e>=0&&e<=1){const n=s+e*g;n>=u&&n<=d&&h.push({t:e,p:[a,n]})}}if(0!==g){const n=(u-s)/g;if(n>=0&&n<=1){const e=o+n*f;e>=c&&e<=a&&h.push({t:n,p:[e,u]})}const e=(d-s)/g;if(e>=0&&e<=1){const n=o+e*f;n>=c&&n<=a&&h.push({t:e,p:[n,d]})}}const x=new Set,I=h.filter(n=>{const{t:e}=n;return!x.has(e)&&(x.add(e),!0)});return I.sort((n,e)=>n.t-e.t).map(n=>n.p)}(o,[[-i,-i],[d,f]]),h=l>-i&&l<d&&c>-i&&c<f,x=u>-i&&u<d&&a>-i&&a<f;if(g.length<2&&!h&&!x)return;const I=u-l,_=a-c,p=u>l?r:-r,v=a>c?r:-r;let m=l,C=c,S=0;const R=p>0,E=v>0,T=R?B:O,b=E?B:O;for(;;){let e=r*T((m+p)/r),t=r*b((C+v)/r);const o=(e-l)/I,x=(t-c)/_,P=o<x&&0!==I||0===_,w=P?e:l+x*I,A=P?c+o*_:t;if((o>1||0===I)&&(x>1||0===_)){const e=B(u/r)+s,t=B(a/r)+s;n[e]?.[t]?.lineSegs.push([[m,C],[u,a]]);break}if(w<=-i||A<=-i||w>=d||A>=f){if(!h&&0===S){[m,C]=g[0],S++;continue}{const e=T(m/r)-(R?0:1)+s,t=b(C/r)-(E?0:1)+s,o=[[m,C],g[S]];n[e]?.[t]?.lineSegs.push(o);break}}const D=T(m/r)-(R?0:1)+s,y=b(C/r)-(E?0:1)+s;n[D]?.[y]?.lineSegs.push([[m,C],[w,A]]),m=w,C=A}}const j=256,{floor:G,ceil:Y}=Math;function Q(n,e,t){const r=e/n.length,[o,s]=t,i=function(n,e){const[t,r]=n,[o,s]=t,[i,l]=r,[c,u,a]=e,d=i-o,f=l-s,g=[],h=[];if(0!==d){const n=(c-o)/d;if(n>=0&&n<=1){const e=s+n*f;e>=u&&e<=a&&(g.push(n),h.push([c,e]))}}if(0!==f){const n=(u-s)/f;if(n>=0&&n<=1){const e=o+n*d;e<=c&&(g.push(n),h.push([e,u]))}const e=(a-s)/f;if(e>=0&&e<=1){const n=o+e*d;n<=c&&(g.push(e),h.push([n,a]))}}return 2===g.length?g[0]<g[1]?h:[h[1],h[0]]:h}(t,[0,0,e]),[l,c]=o,[u,a]=s,d=u-l,f=a-c,g=l<0&&c>0&&c<e,h=u<0&&a>0&&a<e;if(i.length<2&&!g&&!h&&(0!==l||0!==d||c<=0&&a<=0||c>=e&&a>=e))return;if(0===f)return;const x=a>c?r:-r;let I=l,_=c,p=0;const v=u>l,m=a>c,C=m?G:Y;for(;;){let t=v&&I<0||!v&&I>0?0:Number.NEGATIVE_INFINITY,o=r*C((_+x)/r);const u=(t-l)/d,a=(o-c)/f,h=u<a&&0!==d,S=h?0:l+a*d,R=h?c+u*f:o;if((u>1||0===d)&&a>1){const e=G(s[1]/r);n[e]?.push([[I,_],s]);break}if(S>=0&&(0!==l||0!==d)||R<=0||R>=e){if(!g&&0===p){[I,_]=i[0],p++;continue}{const e=C(_/r)-(m?0:1),t=[[I,_],i[p]];n[e]?.push(t);break}}const E=C(_/r)-(m?0:1);n[E]?.push([[I,_],[S,R]]),I=S,_=R}}function V(e,t,o,s,i,l,c,u,f,g,I,_,p,v,m,C){const{gl:S}=e,R=[],E=.03125,T=.03125;R.push(0,0,E,0,0,T),R.push(E,0,E,T,0,T);const b=new Float32Array(R),P=(w=t,(n,e,...t)=>{const{gl:r,uniforms:o}=w,s=o[e]||(o[e]=r.getUniformLocation(w.program,e));r[`uniform${n}`](s,...t)});var w;const D=function(n){return(e,t,r,o,s,i=0,l=0,c=0)=>{const{gl:u,attributes:f}=n,g=f[e]=f[e]??{buf:u.createBuffer(),loc:u.getAttribLocation(n.program,e),data:null},{loc:h,buf:x}=g;u.bindBuffer(u.ARRAY_BUFFER,x),r===a||r===d?u.vertexAttribPointer(h,t,r,!1,l,c):u.vertexAttribIPointer(h,t,r,l,c),u.enableVertexAttribArray(h),0!==i&&u.vertexAttribDivisor(h,i),s!==g.data&&(u.bufferData(u.ARRAY_BUFFER,s,o),g.data=s)}}(t),{lineSegPtCoords_Arr:y,segIdxs_PerCell_Range_Arr:U,closeCellIdxs_PerCell_Arr:F,closeCellIdxs_PerCell_Range_Arr:N,crossCellIdxs_PerCell_Arr:M,crossCellIdxs_perCell_Range_Arr:k,segIdxs_PerStrip_Range_Arr:B}=function(e,t,r,o,s,i,l,c=[0,0,t,r],u=1){const a=function(n,e,t,r){if(0===n[0]&&0===n[1]&&n[2]===e&&n[3]===t)return r;const[o,s,i,l]=n,c=e/i,u=t/l,a=[];for(let n=0;n<r.length;n++){const e=r[n],t=[];for(let n=0;n<e.length;n++){const r=e[n],i=[];for(let n=0;n<r.length;n++){const[e,t]=r[n],l=c*e-o,a=u*t-s;i.push([l,a])}t.push(i)}a.push(t)}return a}(c,t,r/u,e),d=function(n){let e=[];for(let t=0;t<n.length;t++){const r=n[t];for(let n=0;n<r.length;n++){const t=r[n];if(x(t))continue;if(2===t.length){e.push(t);continue}const o=A(t);e.push(...o.filter(n=>!x(n)))}}return e}(a),f=function(e,t){const r=[];for(let o=0;o<e+2*t;o++){const e=[];for(let r=0;r<n+2*t;r++)e.push({lineSegs:[],closeCells:[],crossingCells:[]});r.push(e)}return r}(o,l),g=new Array(n).fill(void 0).map(n=>[]);for(let n=0;n<d.length;n++){const e=d[n];X(f,t,r,s,e,l),Q(g,r,e)}L(f,o,s,i,l),function(e,t,r){for(let o=r;o<t+r;o++)for(let t=r;t<n+r;t++){const s=e[o][t].crossingCells;for(let i=r;i<=o;i++)0!==e[i][t].lineSegs.length&&s.push((n+2*r)*i+t)}}(f,o,l);const h=[],I=[],_=[],p=[],v=[],m=[];let C=0,S=0,R=0;for(let e=0;e<o+2*l;e++)for(let t=0;t<n+2*l;t++){const r=f[e][t];if(e>=l&&e<o+l&&t>=l&&t<n+l){const{closeCells:n,crossingCells:e}=r,t=e.length,o=n.length;v.push(...e),_.push(...n),m.push(C,t),p.push(S,o),C+=t,S+=o}const{lineSegs:s}=r,i=s.length;I.push(R,i),R+=i,h.push(...s.flat(2))}const E=[];for(let e=0;e<n;e++){const n=g[e],t=n.length;E.push([R,t]),R+=t,h.push(...n.flat(2))}for(;_.length%j!==0;)_.push(0);for(;v.length%j!==0;)v.push(0);for(;h.length%1024!=0;)h.push(0);const T=new Float32Array(h),b=new Int32Array(I),P=new Int32Array(p);return{lineSegPtCoords_Arr:T,segIdxs_PerCell_Range_Arr:b,closeCellIdxs_PerCell_Arr:new Int32Array(_),closeCellIdxs_PerCell_Range_Arr:P,crossCellIdxs_PerCell_Arr:new Int32Array(v),crossCellIdxs_perCell_Range_Arr:new Int32Array(m),segIdxs_PerStrip_Range_Arr:new Int32Array(E.flat())}}(o,I,_,p,v,i,m,s,C);D("aUV",2,S.FLOAT,S.STATIC_DRAW,b),D("aCrossIdxRangePerCell",2,S.INT,S.STATIC_DRAW,k,1),D("aCloseCellIdxRangePerCell",2,S.INT,S.STATIC_DRAW,N,1),P("2f","uWidthHeight",I,_),P("1f","uMaxDistance",i),P("1i","uIncl",(l?1:0)+(c?2:0)),P("4f","uCustom",...u),h(t)("SegIdxRangePerCellBlock",0,U),h(t)("SegIdxRangePerStripBlock",1,B),r(e,0,"segs"),S.texImage2D(S.TEXTURE_2D,0,S.RGBA32F,j,y.length/4/j,0,S.RGBA,S.FLOAT,y);const O=S.getUniformLocation(t.program,"uSegs");S.uniform1i(O,0),r(e,1,"closeCellIdxsPerCell"),S.texImage2D(S.TEXTURE_2D,0,S.R32I,j,F.length/j,0,S.RED_INTEGER,S.INT,F);const G=S.getUniformLocation(t.program,"uCloseCellIdxs");S.uniform1i(G,1),r(e,2,"crossCellIdxsPerCell"),S.texImage2D(S.TEXTURE_2D,0,S.R32I,j,M.length/j,0,S.RED_INTEGER,S.INT,M);const Y=S.getUniformLocation(t.program,"uCrossCellIdxs");S.uniform1i(Y,2),C>1&&(S.enable(S.SCISSOR_TEST),S.scissor(f,g,I,_/C)),S.viewport(f,g,I,_),S.drawArraysInstanced(S.TRIANGLES,0,6,p*n),C>1&&S.disable(S.SCISSOR_TEST)}function z(n){const e=[n.p,n.initialPoint];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e}const H={c:function(n){const e=[n.p,[n.vals[0],n.vals[1]],[n.vals[2],n.vals[3]],[n.vals[4],n.vals[5]]];return n.prev2ndCubicControlPoint=e[2],n.prev2ndQuadraticControlPoint=void 0,e},h:function(n){const e=[n.p,[n.vals[0],n.p[1]]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e},l:function(n){const e=[n.p,n.vals];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e},q:function(n){const e=[n.vals[0],n.vals[1]],t=[n.vals[2],n.vals[3]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=e,[n.p,e,t]},s:function(n){const e=n.prev2ndCubicControlPoint?[n.p[0]-n.prev2ndCubicControlPoint[0]+n.p[0],n.p[1]-n.prev2ndCubicControlPoint[1]+n.p[1]]:n.p,t=[n.p,e,[n.vals[0],n.vals[1]],[n.vals[2],n.vals[3]]];return n.prev2ndCubicControlPoint=t[2],n.prev2ndQuadraticControlPoint=void 0,t},t:function(n){const e=n.prev2ndQuadraticControlPoint?[n.p[0]-n.prev2ndQuadraticControlPoint[0]+n.p[0],n.p[1]-n.prev2ndQuadraticControlPoint[1]+n.p[1]]:n.p,t=[n.vals[0],n.vals[1]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=e,[n.p,e,t]},v:function(n){const e=[n.p,[n.p[0],n.vals[0]]];return n.prev2ndCubicControlPoint=void 0,n.prev2ndQuadraticControlPoint=void 0,e},z};function W(n){let e=0,t=0,r=1,o=0,s=1,i=1;const l=n._currentIndex;if(n._skipOptionalSpaces(),n._currentIndex<n._endIndex&&"+"===n._string[n._currentIndex]?n._currentIndex+=1:n._currentIndex<n._endIndex&&"-"===n._string[n._currentIndex]&&(n._currentIndex+=1,s=-1),n._currentIndex===n._endIndex||(n._string[n._currentIndex]<"0"||n._string[n._currentIndex]>"9")&&"."!==n._string[n._currentIndex])throw new Error("The first character of a number must be one of [0-9+-.].");const c=n._currentIndex;for(;n._currentIndex<n._endIndex&&n._string[n._currentIndex]>="0"&&n._string[n._currentIndex]<="9";)n._currentIndex+=1;if(n._currentIndex!==c){let e=n._currentIndex-1,r=1;for(;e>=c;)t+=r*(Number(n._string[e])-0),e-=1,r*=10}if(n._currentIndex<n._endIndex&&"."===n._string[n._currentIndex]){if(n._currentIndex+=1,n._currentIndex>=n._endIndex||n._string[n._currentIndex]<"0"||n._string[n._currentIndex]>"9")throw new Error("There must be a least one digit following the .");for(;n._currentIndex<n._endIndex&&n._string[n._currentIndex]>="0"&&n._string[n._currentIndex]<="9";)r*=10,o+=Number(n._string.charAt(n._currentIndex))/r,n._currentIndex+=1}if(n._currentIndex!==l&&n._currentIndex+1<n._endIndex&&("e"===n._string[n._currentIndex]||"E"===n._string[n._currentIndex])&&"x"!==n._string[n._currentIndex+1]&&"m"!==n._string[n._currentIndex+1]){if(n._currentIndex+=1,"+"===n._string[n._currentIndex]?n._currentIndex+=1:"-"===n._string[n._currentIndex]&&(n._currentIndex+=1,i=-1),n._currentIndex>=n._endIndex||n._string[n._currentIndex]<"0"||n._string[n._currentIndex]>"9")throw new Error("There must be an exponent.");for(;n._currentIndex<n._endIndex&&n._string[n._currentIndex]>="0"&&n._string[n._currentIndex]<="9";)e*=10,e+=Number(n._string[n._currentIndex]),n._currentIndex+=1}let u=t+o;if(u*=s,e&&(u*=Math.pow(10,i*e)),l===n._currentIndex)throw new Error("Internal error: startIndex === source._currentIndex");return n._skipOptionalSpacesOrDelimiter(),u}const q={Z:"Z",M:"M",L:"L",C:"C",Q:"Q",A:"A",H:"H",V:"V",S:"S",T:"T",z:"Z",m:"m",l:"l",c:"c",q:"q",a:"a",h:"h",v:"v",s:"s",t:"t"};class Z{_string;_currentIndex;_endIndex;_prevCommand;constructor(n){this._string=n,this._currentIndex=0,this._endIndex=this._string.length,this._prevCommand=void 0,this._skipOptionalSpaces()}parseSegment(){const n=this._string[this._currentIndex];let e,t=q[n];if(void 0===t){if(void 0===this._prevCommand)throw new Error("Implicit command not allowed for first commands.");if(!("+"===n||"-"===n||"."===n||n>="0"&&n<="9")||"Z"===this._prevCommand)throw new Error("Remaining coordinates not found for implicit command");t="M"===this._prevCommand?"L":"m"===this._prevCommand?"l":this._prevCommand}else this._currentIndex+=1;this._prevCommand=t;const r=t.toUpperCase();if("H"===r||"V"===r?e=[W(this)]:"M"===r||"L"===r||"T"===r?e=[W(this),W(this)]:"S"===r||"Q"===r?e=[W(this),W(this),W(this),W(this)]:"C"===r?e=[W(this),W(this),W(this),W(this),W(this),W(this)]:"A"===r?e=[W(this),W(this),W(this),this._parseArcFlag(),this._parseArcFlag(),W(this),W(this)]:"Z"===r&&(this._skipOptionalSpaces(),e=[]),void 0===e)throw new Error("Unknown command");return{type:t,values:e}}hasMoreData(){return this._currentIndex<this._endIndex}initialCommandIsMoveTo(){if(!this.hasMoreData())return!0;const n=q[this._string[this._currentIndex]];return"M"===n||"m"===n}_isCurrentSpace(){const n=this._string[this._currentIndex];return n<=" "&&(" "===n||"\n"===n||"\t"===n||"\r"===n||"\f"===n)}_skipOptionalSpaces(){for(;this._currentIndex<this._endIndex&&this._isCurrentSpace();)this._currentIndex+=1;return this._currentIndex<this._endIndex}_skipOptionalSpacesOrDelimiter(){return!(this._currentIndex<this._endIndex&&!this._isCurrentSpace()&&","!==this._string[this._currentIndex])&&(this._skipOptionalSpaces()&&this._currentIndex<this._endIndex&&","===this._string[this._currentIndex]&&(this._currentIndex+=1,this._skipOptionalSpaces()),this._currentIndex<this._endIndex)}_parseArcFlag(){if(this._currentIndex>=this._endIndex)throw new Error("Unable to parse arc flag");let n;const e=this._string[this._currentIndex];if(this._currentIndex+=1,"0"===e)n=0;else{if("1"!==e)throw new Error("Unable to parse arc flag - arc flag must be 0 or 1");n=1}return this._skipOptionalSpacesOrDelimiter(),n}}const{ceil:$,min:J,max:K}=Math;function nn(r,o,s,i,l,c=0,u=0,a,d=!0,f=!0,g,h=0){const x="string"==typeof o?function(n){if(0===n.length)return[];if("m"!==n[0].type.toLowerCase())throw new Error("Invalid SVG - every new path must start with an M or m.");const e={p:[0,0]},t=[];let r,o=[];for(let s=0;s<n.length;s++){const i=n[s],l=i.type.toLowerCase();if(e.vals=i.values,i.type===l)if("v"===l)e.vals[0]+=e.p[1];else if("a"===l)e.vals[5]+=e.p[0],e.vals[6]+=e.p[1];else for(let n=0;n<e.vals.length;n++)e.vals[n]+=e.p[n%2];if("m"===l){o.length&&("z"!==r&&o.push(z(e)),t.push(o),o=[]),e.initialPoint=e.p=e.vals,r=l;continue}const c=H[l];if(!c)throw new Error("Invalid SVG - command not recognized.");const u=c(e);e.p=u[u.length-1],o.push(u),r=l}return o.length>0&&("z"!==r&&o.push(z(e)),t.push(o)),t}(function(n){if(!n.length)return[];const e=new Z(n),t=[];if(!e.initialCommandIsMoveTo())throw new Error("Path must start with m or M");for(;e.hasMoreData();)t.push(e.parseSegment());return t}(o)):o;let I=1;if(i/l>4){const n=i/4;I=n/l,l=n}const _=l/n,p=K(i,l),v=$(i/_),m=2*$(J(a,p)/_/2),C=function(n,e,r,o){const{gl:s,programs:i}=n;if(i[e])return i[e];const l=s.createProgram(),c=t(s,"#version 300 es\n\nprecision highp float;\n\nuniform vec2 uWidthHeight;\nin vec2 aUV;\nin ivec2 aCloseCellIdxRangePerCell;\nin ivec2 aCrossIdxRangePerCell;\nout vec2 vXY;\nflat out int instanceId;\nflat out ivec2 closeCellIdxRange;\nflat out ivec2 crossCellIdxRange;\n\n\nvoid main() {\n    instanceId = gl_InstanceID;\n    closeCellIdxRange = aCloseCellIdxRangePerCell;\n    crossCellIdxRange = aCrossIdxRangePerCell;\n\n    // drawn column-by-column\n    float i = float(instanceId / 32);  // column index\n    float j = float(instanceId % 32);  // row index\n\n    vec2 trans = vec2(\n        i / float(32),\n        j / float(32)\n    );\n\n    vec2 uv = aUV + trans;\n\n    float width = uWidthHeight.x;\n    float height = uWidthHeight.y;\n\n    vXY = vec2(\n        height * uv.x,\n        height * uv.y\n    );\n\n    float aspectRatio = width / height;\n\n    gl_Position = vec4(\n        vec2(\n            (2.0*(uv.x / aspectRatio) - 1.0),\n            (2.0*uv.y - 1.0)\n        ),\n        0.0, 1.0\n    );\n}\n",s.VERTEX_SHADER),u=t(s,o,s.FRAGMENT_SHADER);return s.attachShader(l,c),s.attachShader(l,u),s.linkProgram(l),i[e]={gl:s,program:l,attributes:{},uniforms:{},uniformBlocks:{},vertexShader:c,fragmentShader:u},i[e]}(r,`main${v}-${m}`,0,function(t,r){const o=e[1024*t+r];if(void 0!==o)return o;const s=`#version 300 es\n\nprecision highp float;\n\nuniform float uMaxDistance;\nuniform highp sampler2D uSegs;\nuniform highp isampler2D uCloseCellIdxs;\nuniform highp isampler2D uCrossCellIdxs;\nuniform int uIncl;  // bit 0 -> incl inside, bit 1 -> incl outside\n\nuniform SegIdxRangePerCellBlock {\n    ivec4 uSegIdxRangePerCell[${(n+2*r)*(t+2*r)/2}];\n};\nuniform SegIdxRangePerStripBlock {\n    ivec4 uSegIdxRangePerStrip[16];\n};\n\nin vec2 vXY;\nflat in int instanceId;\nflat in ivec2 closeCellIdxRange;\nflat in ivec2 crossCellIdxRange;\nout vec4 FragColor;\n\n\nfloat absDistToSegment(vec2 point, vec2 lineA, vec2 lineB) {\n    vec2 lineDir = lineB - lineA;\n    float lenSq = dot(lineDir, lineDir);\n    float t = clamp(dot(point - lineA, lineDir) / lenSq, 0.0, 1.0);\n    vec2 linePt = lineA + t*lineDir;\n\n    return distance(point, linePt);\n}\n\n\nvoid main() {\n    ///////////////////////////////////////////////////////////////////////////\n    // Project a ray to the left to check if it crosses the segment in order\n    // to find the fragment's winding number to determine whether fragment\n    // is inside or outside the shape.\n\n    int crossIdxS = crossCellIdxRange.x;\n    int crossLen = crossCellIdxRange.y;\n    float winds = 0.0;\n    // Iterate over all relevant cell indexes\n    for (int i = crossIdxS; i < crossIdxS + crossLen; i++) {\n        int crossIdx = texelFetch(uCrossCellIdxs, ivec2(i%256, i/256), 0).x;\n\n        ivec2 uSegIdxRange = crossIdx % 2 == 0\n            ? uSegIdxRangePerCell[crossIdx / 2].xy\n            : uSegIdxRangePerCell[crossIdx / 2].zw;\n\n        int segIdx = uSegIdxRange.x;\n        int segLen = uSegIdxRange.y;\n\n        for (int j = segIdx; j < segIdx + segLen; j++) {\n            // Fetch segment from texture\n            vec4 seg = texelFetch(uSegs, ivec2(j%256, j/256), 0);\n\n            // line segment's min-y is excluded\n            bool crossing =\n                (seg.y > vXY.y != seg.w > vXY.y) &&\n                (vXY.x > (seg.z - seg.x)*(vXY.y - seg.y) / (seg.w - seg.y) + seg.x);\n\n            bool crossingUp = seg.y < seg.w;\n\n            winds += crossing ? (crossingUp ? 1.0 : -1.0) : 0.0;\n        }\n    }\n\n    {\n        int cellIdx = (instanceId % 32);\n\n        bool isEven = cellIdx % 2 == 0;\n\n        ivec4 uSegIdxRange = uSegIdxRangePerStrip[cellIdx / 2];\n        int segIdx = isEven ? uSegIdxRange.x : uSegIdxRange.z;\n        int segLen = isEven ? uSegIdxRange.y : uSegIdxRange.w;\n        \n\n        for (int j = segIdx; j < segIdx + segLen; j++) {\n            // Fetch segment from texture\n            vec4 seg = texelFetch(uSegs, ivec2(j%256, j/256), 0);\n\n            // line segment's min-y is excluded\n            bool crossing =\n                (seg.y > vXY.y != seg.w > vXY.y) &&\n                (vXY.x > (seg.z - seg.x)*(vXY.y - seg.y) / (seg.w - seg.y) + seg.x);\n\n            bool crossingUp = seg.y < seg.w;\n\n            winds += crossing ? (crossingUp ? 1.0 : -1.0) : 0.0;\n        }\n    }\n\n\n    bool inside = winds != 0.0;\n    ///////////////////////////////////////////////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////\n    float res = 1.0;  // sdf result\n\n    if ((inside && (uIncl % 2 != 0)) || (!inside && (uIncl > 1))) {\n        int cellIdxS = closeCellIdxRange.x;\n        int cellLen = closeCellIdxRange.y;\n        // Iterate over all relevant cell indexes\n        for (int i = cellIdxS; i < cellIdxS + cellLen; i++) {\n            int cellIdx = texelFetch(uCloseCellIdxs, ivec2(i%256, i/256), 0).x;\n\n            ivec2 uSegIdxRange = cellIdx % 2 == 0\n                ? uSegIdxRangePerCell[cellIdx / 2].xy\n                : uSegIdxRangePerCell[cellIdx / 2].zw;\n\n            int segIdx = uSegIdxRange.x;\n            int segLen = uSegIdxRange.y;\n\n            for (int j = segIdx; j < segIdx + segLen; j++) {\n                // Fetch segment from texture\n                vec4 seg = texelFetch(uSegs, ivec2(j%256, j/256), 0);\n\n                // Find unsigned distance to the segment; only the nearest will be kept\n                float d = absDistToSegment(vXY, seg.xy, seg.zw);\n                // Apply exponential transform\n                float val = clamp(d / uMaxDistance, 0.0, 1.0);\n\n                res = min(res, val);\n            }\n        }\n    }\n    ///////////////////////////////////////////////////////////////////////////\n\n    // DEBUG!\n    // float alpha = ((instanceId + instanceId/32) % 2 == 0 ? 0.3 : 0.5);\n\n\n    float exponent = 2;\n    res = pow(1.0 - val, exponent) * 0.5;\n\n    float alpha = res == 1.0 ? 0.0 : 0.5;\n    float red = inside ? 0.2 : 0.8;\n    float green = abs(sin(25.0 * res));\n    float blue = 0.5;\n\n    FragColor = vec4(red, green, blue, alpha);\n}\n`;return e[1024*t+r]=s,s}(v,m)),{gl:S}=r;S.useProgram(C.program),V(r,C,x,s,a,d,f,g,c,u,i,l,v,_,m,I)}function en(n){if(void 0===n)return;const{gl:e,programs:t,textures:r}=n;for(let n in t){const{attributes:r,fragmentShader:o,vertexShader:s,uniformBlocks:i,program:l}=t[n];for(let n in i){const{buf:t}=i[n];e.deleteBuffer(t)}for(let n in r){const{buf:t}=r[n];e.deleteBuffer(t)}e.deleteShader(o),e.deleteShader(s),e.deleteProgram(l)}for(let n in r){const{tex:t}=r[n];e.deleteTexture(t)}}const tn=new WeakMap;function rn(n){{const e=tn.get(n);if(e)return e}const e={},t={},r={gl:n,textures:t,programs:e};return n.canvas.addEventListener("webglcontextlost",o=>{on(e),on(t),tn.delete(n),r.onContextLoss?.(o)},!1),tn.set(n,r),r}function on(n){Object.keys(n).forEach(e=>{delete n[e]})}export{en as freeGlContext,nn as generateSdf,rn as getWebGlContext};